---
title: "Request-scoped async database session example."
description: |
  This example demonstrates how to properly handle async database sessions
  with request-scoped dependency injection to avoid event loop binding issues.
  
  Run:
      python examples/16-async-database-scoped.py
  
  Then test:
      curl http://localhost:8016/users
      curl -X POST http://localhost:8016/users -H "Content-Type: application/json" -d '\{"name":"Alice","email":"alice@example.com"\}'
---

import { Code } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';

<div class="example-header">
  <Badge text="Intermediate" variant="caution" />
  <Badge text="Database" variant="note" />
  
  
</div>

## Overview

This example demonstrates how to properly handle async database sessions
with request-scoped dependency injection to avoid event loop binding issues.

Run:
    python examples/16-async-database-scoped.py

Then test:
    curl http://localhost:8016/users
    curl -X POST http://localhost:8016/users -H "Content-Type: application/json" -d '\{"name":"Alice","email":"alice@example.com"\}'



## Running This Example

```bash
# Clone the repository
git clone https://github.com/nijaru/zenith.git
cd zenith

# Set required environment variable
export SECRET_KEY="your-secret-key-at-least-32-characters-long"

# Run the example
uv run python examples/16-async-database-scoped.py
```

## Source Code

<Code code={`#!/usr/bin/env python3
"""
Request-scoped async database session example.

This example demonstrates how to properly handle async database sessions
with request-scoped dependency injection to avoid event loop binding issues.

Run:
    python examples/16-async-database-scoped.py

Then test:
    curl http://localhost:8016/users
    curl -X POST http://localhost:8016/users -H "Content-Type: application/json" -d '\{"name":"Alice","email":"alice@example.com"\}'
"""

import asyncio
from typing import AsyncGenerator

from pydantic import BaseModel
from sqlalchemy import Column, Integer, String, select
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from sqlalchemy.orm import declarative_base

from zenith import DatabaseSession, RequestScoped, Zenith

# SQLAlchemy models
Base = declarative_base()


class UserModel(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)


# Pydantic models
class UserCreate(BaseModel):
    name: str
    email: str


class User(BaseModel):
    id: int
    name: str
    email: str

    class Config:
        from_attributes = True


# Database setup - This can be at module level!
# The engine binding to event loop happens here, but sessions are created per-request
DATABASE_URL = "sqlite+aiosqlite:///:memory:"
engine = create_async_engine(DATABASE_URL, echo=False)
async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)


# Session factory for request-scoped injection
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Create a new database session for each request.

    This ensures the session is created in the correct async context
    and properly cleaned up after the request.
    """
    async with async_session_maker() as session:
        yield session


# Create the app
app = Zenith(
    title="Async Database Example",
    version="1.0.0",
    debug=True,
)


@app.on_startup
async def startup():
    """Create database tables on startup."""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    print("âœ… Database tables created")


@app.on_shutdown
async def shutdown():
    """Clean up database connections on shutdown."""
    await engine.dispose()
    print("âœ… Database connections closed")


@app.get("/users", response_model=list[User])
async def get_users(db: AsyncSession = DatabaseSession(get_db)):
    """
    Get all users.

    The database session is properly scoped to this request,
    avoiding event loop binding issues.
    """
    result = await db.execute(select(UserModel))
    users = result.scalars().all()
    return [User.model_validate(u) for u in users]


@app.post("/users", response_model=User)
async def create_user(user_data: UserCreate, db: AsyncSession = DatabaseSession(get_db)):
    """
    Create a new user.

    Each request gets its own database session created in the
    correct async context.
    """
    user = UserModel(name=user_data.name, email=user_data.email)
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return User.model_validate(user)


@app.get("/users/\{user_id\}", response_model=User)
async def get_user(user_id: int, db: AsyncSession = DatabaseSession(get_db)):
    """
    Get a specific user by ID.

    Demonstrates that each endpoint gets its own properly scoped session.
    """
    result = await db.execute(select(UserModel).where(UserModel.id == user_id))
    user = result.scalar_one_or_none()
    if not user:
        raise HTTPException(404, "User not found")
    return User.model_validate(user)


# Alternative: Using RequestScoped directly
@app.get("/users/alt/list", response_model=list[User])
async def get_users_alt(db: AsyncSession = RequestScoped(get_db)):
    """
    Alternative syntax using RequestScoped directly.

    DatabaseSession is just a specialized RequestScoped for clarity.
    """
    result = await db.execute(select(UserModel))
    users = result.scalars().all()
    return [User.model_validate(u) for u in users]


# Test concurrent requests
async def test_concurrent_requests():
    """Test that concurrent requests work without event loop issues."""
    from httpx import AsyncClient

    async with AsyncClient(base_url="http://localhost:8016") as client:
        # Create users concurrently
        tasks = [
            client.post("/users", json=\{"name": f"User\{i\}", "email": f"user\{i\}@example.com"\})
            for i in range(5)
        ]
        results = await asyncio.gather(*tasks)

        for r in results:
            assert r.status_code == 200, f"Failed: \{r.text\}"

        # Get users concurrently
        tasks = [client.get("/users") for _ in range(10)]
        results = await asyncio.gather(*tasks)

        for r in results:
            assert r.status_code == 200, f"Failed: \{r.text\}"
            assert len(r.json()) == 5, "Should have 5 users"

        print("âœ… Concurrent request test passed!")


if __name__ == "__main__":
    print("ðŸš€ Starting Async Database Example with Request-Scoped Sessions")
    print("ðŸ“ Server will start at: http://localhost:8016")
    print("\nðŸ“– This example demonstrates:")
    print("   â€¢ Request-scoped database sessions")
    print("   â€¢ Proper async context isolation")
    print("   â€¢ No event loop binding issues")
    print("   â€¢ Safe concurrent request handling")
    print("\nðŸ”— Try these endpoints:")
    print("   GET  /users           - List all users")
    print("   POST /users           - Create a user")
    print("   GET  /users/\{id\}      - Get specific user")
    print("   GET  /users/alt/list  - Alternative syntax example")

    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8016)`} lang="python" title="examples/16-async-database-scoped.py" />

## What This Example Demonstrates

**Database Integration**: ZenithModel usage with automatic session management

**Route Handlers**: HTTP endpoint definition and request handling

## Next Steps

- **Modify the code**: Try changing the routes or adding new features
- **Run tests**: Add test cases for your modifications
- **Explore more**: Check out other examples in the [examples directory](https://github.com/nijaru/zenith/tree/main/examples)
- **Read the docs**: Learn more about [Zenith concepts](/concepts/)

---

*This page is auto-generated from [`examples/16-async-database-scoped.py`](https://github.com/nijaru/zenith/blob/main/examples/16-async-database-scoped.py).
To suggest changes, edit the source file and the documentation will update automatically.*
