"""
Zenith CLI - Command-line interface for Zenith web applications.

Focused on reliable, high-value developer tools.
"""

import subprocess
import sys
from pathlib import Path

import click

from zenith.__version__ import __version__


@click.group()
@click.version_option(version=__version__, package_name="zenith-web")
def main():
    """Zenith - Modern Python web framework."""
    pass


# ============================================================================
# SECURITY AUTOMATION - Eliminate manual security steps
# ============================================================================


@main.command()
@click.option("--output", "-o", help="Output file (e.g., .env, .env.production)")
@click.option("--env", type=click.Choice(["development", "production", "staging", "test"]), help="Environment preset")
@click.option("--format", type=click.Choice(["env", "docker", "json", "python"]), default="env", help="Output format")
@click.option("--length", default=64, type=int, help="Key length in bytes (default: 64)")
@click.option("--force", is_flag=True, help="Overwrite existing key in file")
def keygen(output: str | None, env: str | None, format: str, length: int, force: bool):
    """Generate cryptographically secure SECRET_KEY for your application.

    Examples:
      zen keygen                                 # Print key to stdout
      zen keygen --output .env                   # Append to .env file
      zen keygen --env production --output .env.prod  # Production .env
      zen keygen --format docker                 # Docker ENV format
      zen keygen --format json                   # JSON format
    """
    import secrets
    from datetime import datetime

    # Generate cryptographically secure key
    secret_key = secrets.token_urlsafe(length)

    # Get current timestamp for comments
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

    # Environment-specific comments and settings
    env_config = {
        "development": {
            "comment": "Development environment - safe for local testing",
            "debug": "true",
            "cors_origins": "*"
        },
        "production": {
            "comment": "Production environment - keep this key secure!",
            "debug": "false",
            "cors_origins": "https://yourdomain.com"
        },
        "staging": {
            "comment": "Staging environment - production-like testing",
            "debug": "false",
            "cors_origins": "https://staging.yourdomain.com"
        },
        "test": {
            "comment": "Test environment - for automated testing",
            "debug": "true",
            "cors_origins": "*"
        }
    }

    # Format output based on requested format
    if format == "env":
        if env:
            config = env_config[env]
            content = f"""# Generated by Zenith CLI on {timestamp}
# Environment: {env} - {config['comment']}
SECRET_KEY={secret_key}
ZENITH_ENV={env}
DEBUG={config['debug']}
CORS_ORIGINS={config['cors_origins']}

# Add your other environment variables below:
# DATABASE_URL=sqlite:///./app.db
# REDIS_URL=redis://localhost:6379
"""
        else:
            content = f"""# Generated by Zenith CLI on {timestamp}
SECRET_KEY={secret_key}
"""

    elif format == "docker":
        content = f"ENV SECRET_KEY={secret_key}"

    elif format == "json":
        import json
        content = json.dumps({
            "SECRET_KEY": secret_key,
            "generated_at": timestamp,
            "length": length
        }, indent=2)

    elif format == "python":
        content = f'''# Generated by Zenith CLI on {timestamp}
SECRET_KEY = "{secret_key}"
'''

    # Output handling
    if output:
        output_path = Path(output)

        # Check if file exists and contains SECRET_KEY
        key_exists = False
        if output_path.exists():
            existing_content = output_path.read_text()
            key_exists = "SECRET_KEY=" in existing_content

        if key_exists and not force:
            click.echo(f"❌ SECRET_KEY already exists in {output}")
            click.echo("   Use --force to overwrite existing key")
            click.echo("   Or remove the existing SECRET_KEY line manually")
            sys.exit(1)

        try:
            if key_exists and force:
                # Replace existing SECRET_KEY line
                lines = output_path.read_text().splitlines()
                updated_lines = []
                key_replaced = False

                for line in lines:
                    if line.startswith("SECRET_KEY=") and not key_replaced:
                        updated_lines.append(f"SECRET_KEY={secret_key}")
                        key_replaced = True
                    else:
                        updated_lines.append(line)

                output_path.write_text("\n".join(updated_lines) + "\n")
                click.echo(f"🔄 Updated SECRET_KEY in {output}")
            else:
                # Append to file or create new
                if output_path.exists() and format == "env":
                    # Append with newline separator
                    with output_path.open("a") as f:
                        f.write(f"\n{content.strip()}\n")
                else:
                    output_path.write_text(content)

                click.echo(f"✅ SECRET_KEY written to {output}")

            # Show security reminder for production
            if env == "production":
                click.echo("🔒 SECURITY REMINDER:")
                click.echo("   • Never commit this key to version control")
                click.echo("   • Set this as an environment variable in production")
                click.echo("   • Rotate keys regularly in production environments")

        except PermissionError:
            click.echo(f"❌ Permission denied writing to {output}")
            sys.exit(1)
        except Exception as e:
            click.echo(f"❌ Error writing to {output}: {e}")
            sys.exit(1)
    else:
        # Print to stdout
        if format == "env":
            click.echo(secret_key)
        else:
            click.echo(content)

        # Security reminder when outputting to terminal
        if format == "env" and not env:
            click.echo("\n💡 Tip: Use --output .env to save directly to file", err=True)
            click.echo("        Use --env production for production settings", err=True)


# ============================================================================
# DEVELOPMENT TOOLS - Reliable, high-value commands
# ============================================================================


@main.command()
@click.argument("name")
@click.option("--template", type=click.Choice(["api", "webapp", "micro"]), default="api", help="Project template")
@click.option("--path", default=".", help="Directory to create project in")
def init(name: str, template: str, path: str):
    """Create a new Zenith project with best-practice templates.

    Templates:
      api     - Basic API with authentication and database (default)
      webapp  - Full-stack webapp with frontend integration
      micro   - Microservice pattern with health checks and metrics

    Examples:
      zen init my-api                      # Basic API structure
      zen init my-app --template webapp    # Full-stack webapp
      zen init my-service --template micro # Microservice pattern
    """
    import secrets

    project_path = Path(path) / name

    click.echo(f"🚀 Creating new Zenith {template}: {name}")
    click.echo(f"📁 Path: {project_path}")

    # Create project directory
    try:
        project_path.mkdir(parents=True, exist_ok=False)
    except FileExistsError:
        click.echo(f"❌ Directory {project_path} already exists")
        click.echo("   Choose a different name or remove the existing directory")
        sys.exit(1)

    # Generate secure secret key (64 bytes for stronger entropy)
    secret_key = secrets.token_urlsafe(64)

    # Template-specific content generation
    templates = {
        "api": _generate_api_template,
        "webapp": _generate_webapp_template,
        "micro": _generate_micro_template
    }

    template_generator = templates[template]
    files_to_create = template_generator(name, secret_key)

    # Write all files
    for filename, content in files_to_create:
        file_path = project_path / filename
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content.strip())
        click.echo(f"  ✓ {filename}")

    click.echo("\n✅ Project created successfully!")
    click.echo("\nNext steps:")
    click.echo(f"  cd {name}")
    click.echo("  pip install -r requirements.txt")
    click.echo("  zen dev                         # Start development server")
    if template == "webapp":
        click.echo("  # Configure frontend build in package.json")
    elif template == "micro":
        click.echo("  # Configure service discovery and monitoring")


def _generate_api_template(name: str, secret_key: str) -> list[tuple[str, str]]:
    """Generate basic API template files."""

    app_py_content = f'''"""
{name} - Zenith API application.
"""

from zenith import Zenith

# Create your Zenith app
app = Zenith()


@app.get("/")
async def root():
    """API root endpoint."""
    return {{"message": "Welcome to {name} API!", "status": "running"}}


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {{"status": "healthy", "service": "{name}"}}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000, reload=True)
'''

    env_content = f'''# Environment variables for {name}
SECRET_KEY={secret_key}
ZENITH_ENV=development
DEBUG=true

# Database (uncomment and configure as needed)
# DATABASE_URL=sqlite:///./app.db

# Redis (uncomment if using caching/sessions)
# REDIS_URL=redis://localhost:6379
'''

    requirements_content = '''zenith-web>=0.3.0
uvicorn[standard]>=0.20.0
'''

    gitignore_content = '''# Python
__pycache__/
*.py[cod]
*.so
.Python
.venv/
venv/
ENV/

# Environment
.env
.env.local

# Database
*.db
*.sqlite

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
'''

    readme_content = f'''# {name}

A modern API built with [Zenith](https://zenith-python.org).

## Quick Start

1. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

2. Start development server:
   ```bash
   zen dev
   ```

3. Visit http://localhost:8000 to see your API!

## API Endpoints

- `GET /` - API root
- `GET /health` - Health check
- `GET /docs` - Interactive API documentation

## Project Structure

- `app.py` - Main application file
- `.env` - Environment variables (configure your secrets here)
- `requirements.txt` - Python dependencies

## Next Steps

- Add your business logic and models
- Configure database connection in `.env`
- Add authentication with `app.add_auth()`
- Deploy to production

## Learn More

- [Zenith Documentation](https://zenith-python.org)
- [API Examples](https://zenith-python.org/examples)
'''

    return [
        ("app.py", app_py_content),
        (".env", env_content),
        ("requirements.txt", requirements_content),
        (".gitignore", gitignore_content),
        ("README.md", readme_content),
    ]


def _generate_webapp_template(name: str, secret_key: str) -> list[tuple[str, str]]:
    """Generate full-stack webapp template files."""

    app_py_content = f'''"""
{name} - Zenith Full-Stack Web Application.
"""

from zenith import Zenith

# Create your Zenith app with webapp features
app = (Zenith()
       .add_auth()           # JWT authentication
       .add_api("{name}", "1.0.0", "Full-stack web application")
       .add_admin())         # Admin dashboard


@app.get("/")
async def root():
    """Frontend home page."""
    return {{"message": "Welcome to {name}!", "type": "webapp"}}


@app.get("/api/")
async def api_root():
    """API root endpoint."""
    return {{"message": "{name} API", "version": "1.0.0"}}


# Static file serving for frontend
from zenith.web.static import StaticFiles
app.mount("/static", StaticFiles(directory="frontend/dist"), name="static")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000, reload=True)
'''

    env_content = f'''# Environment variables for {name}
SECRET_KEY={secret_key}
ZENITH_ENV=development
DEBUG=true

# Database
DATABASE_URL=sqlite:///./app.db

# Frontend build
FRONTEND_DIR=frontend/dist

# CORS for frontend development
CORS_ORIGINS=http://localhost:3000,http://localhost:5173

# Redis (uncomment if using sessions/caching)
# REDIS_URL=redis://localhost:6379
'''

    requirements_content = '''zenith-web>=0.3.0
uvicorn[standard]>=0.20.0
sqlalchemy>=2.0.0
aiosqlite>=0.19.0
'''

    package_json_content = f'''{{
  "name": "{name.lower().replace('_', '-')}-frontend",
  "version": "1.0.0",
  "description": "Frontend for {name}",
  "scripts": {{
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }},
  "devDependencies": {{
    "vite": "^4.4.0"
  }}
}}'''

    frontend_index_html = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{name}</title>
</head>
<body>
    <div id="app">
        <h1>Welcome to {name}!</h1>
        <p>Your Zenith full-stack application is running.</p>
        <div id="api-status">Loading API status...</div>
    </div>

    <script>
        // Simple API integration example
        fetch('/api/')
            .then(res => res.json())
            .then(data => {{
                document.getElementById('api-status').innerHTML =
                    `<p>✅ API connected: ${{data.message}}</p>`;
            }})
            .catch(err => {{
                document.getElementById('api-status').innerHTML =
                    `<p>❌ API connection failed</p>`;
            }});
    </script>
</body>
</html>'''

    gitignore_content = '''# Python
__pycache__/
*.py[cod]
*.so
.Python
.venv/
venv/
ENV/

# Environment
.env
.env.local

# Database
*.db
*.sqlite

# Frontend
node_modules/
frontend/dist/
frontend/.vite/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
'''

    readme_content = f'''# {name}

A modern full-stack web application built with [Zenith](https://zenith-python.org).

## Features

- 🔐 **Authentication** - JWT-based user authentication
- 📊 **Admin Dashboard** - Built-in admin interface
- 🎨 **Frontend Integration** - Static file serving and API integration
- 📝 **API Documentation** - Interactive Swagger/OpenAPI docs
- 🗄️ **Database** - SQLite with SQLAlchemy ORM

## Quick Start

1. **Backend Setup:**
   ```bash
   pip install -r requirements.txt
   zen dev
   ```

2. **Frontend Setup** (optional):
   ```bash
   cd frontend
   npm install
   npm run dev        # Development server
   npm run build      # Production build
   ```

3. Visit http://localhost:8000 to see your app!

## Project Structure

```
{name}/
├── app.py              # Main application
├── .env                # Environment variables
├── requirements.txt    # Python dependencies
├── frontend/           # Frontend application
│   ├── package.json    # Node.js dependencies
│   └── index.html      # Main HTML file
└── README.md           # This file
```

## API Endpoints

- `GET /` - Frontend home page
- `GET /api/` - API root
- `GET /docs` - Interactive API documentation
- `GET /admin` - Admin dashboard
- `POST /auth/login` - User authentication

## Next Steps

- Configure your database models
- Add user registration and profiles
- Customize the frontend with your preferred framework (React, Vue, etc.)
- Add business logic and API endpoints
- Deploy to production

## Learn More

- [Zenith Documentation](https://zenith-python.org)
- [Full-Stack Examples](https://zenith-python.org/examples/webapp)
'''

    return [
        ("app.py", app_py_content),
        (".env", env_content),
        ("requirements.txt", requirements_content),
        ("package.json", package_json_content),
        ("frontend/index.html", frontend_index_html),
        (".gitignore", gitignore_content),
        ("README.md", readme_content),
    ]


def _generate_micro_template(name: str, secret_key: str) -> list[tuple[str, str]]:
    """Generate microservice template files."""

    app_py_content = f'''"""
{name} - Zenith Microservice.
"""

from zenith import Zenith

# Create your Zenith microservice
app = Zenith()

# Add production microservice features
app.add_api("{name}", "1.0.0", "Production microservice")


@app.get("/")
async def root():
    """Service information."""
    return {{
        "service": "{name}",
        "version": "1.0.0",
        "status": "running",
        "type": "microservice"
    }}


@app.get("/health")
async def health():
    """Kubernetes-compatible health check."""
    return {{
        "status": "healthy",
        "service": "{name}",
        "checks": {{
            "database": "healthy",
            "memory": "healthy",
            "disk": "healthy"
        }}
    }}


@app.get("/ready")
async def ready():
    """Kubernetes readiness probe."""
    return {{
        "status": "ready",
        "service": "{name}",
        "uptime": "0s"  # TODO: Implement actual uptime
    }}


@app.get("/metrics")
async def metrics():
    """Prometheus-compatible metrics endpoint."""
    # TODO: Implement actual metrics collection
    return {{
        "requests_total": 0,
        "requests_duration_seconds": 0.0,
        "memory_usage_bytes": 0
    }}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''

    env_content = f'''# Environment variables for {name}
SECRET_KEY={secret_key}
ZENITH_ENV=production
DEBUG=false

# Service configuration
SERVICE_NAME={name}
SERVICE_VERSION=1.0.0
SERVICE_PORT=8000

# Database
DATABASE_URL=postgresql://user:pass@db:5432/dbname

# Redis (for caching/sessions)
REDIS_URL=redis://redis:6379

# Monitoring
METRICS_ENABLED=true
HEALTH_CHECK_TIMEOUT=5

# Security
CORS_ORIGINS=https://api.yourdomain.com
'''

    requirements_content = '''zenith-web>=0.3.0
uvicorn[standard]>=0.20.0
psycopg2-binary>=2.9.0
redis>=4.5.0
prometheus-client>=0.16.0
'''

    dockerfile_content = f'''FROM python:3.12-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash app \\
    && chown -R app:app /app
USER app

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:8000/health || exit 1

# Expose port
EXPOSE 8000

# Run the application
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
'''

    docker_compose_content = f'''version: '3.8'

services:
  {name.lower().replace('_', '-')}:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/{name.lower()}
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: {name.lower()}
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
'''

    k8s_deployment_content = f'''apiVersion: apps/v1
kind: Deployment
metadata:
  name: {name.lower().replace('_', '-')}
  labels:
    app: {name.lower().replace('_', '-')}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: {name.lower().replace('_', '-')}
  template:
    metadata:
      labels:
        app: {name.lower().replace('_', '-')}
    spec:
      containers:
      - name: {name.lower().replace('_', '-')}
        image: {name.lower().replace('_', '-')}:latest
        ports:
        - containerPort: 8000
        env:
        - name: ZENITH_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: {name.lower().replace('_', '-')}-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: {name.lower().replace('_', '-')}-secrets
              key: secret-key
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: {name.lower().replace('_', '-')}-service
spec:
  selector:
    app: {name.lower().replace('_', '-')}
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
'''

    gitignore_content = '''# Python
__pycache__/
*.py[cod]
*.so
.Python
.venv/
venv/
ENV/

# Environment
.env
.env.local
.env.production

# Database
*.db
*.sqlite

# Docker
.dockerignore

# Kubernetes
*.kubeconfig

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Monitoring
prometheus/
grafana/
'''

    readme_content = f'''# {name}

A production-ready microservice built with [Zenith](https://zenith-python.org).

## Features

- 🏥 **Health Checks** - Kubernetes-compatible liveness and readiness probes
- 📊 **Metrics** - Prometheus-compatible metrics endpoint
- 🐳 **Containerized** - Docker and Docker Compose ready
- ☸️ **Kubernetes** - Deployment manifests included
- 🔒 **Production Security** - Security headers, CORS, and rate limiting
- 📝 **API Documentation** - Interactive Swagger/OpenAPI docs

## Quick Start

### Local Development
```bash
pip install -r requirements.txt
zen dev
```

### Docker Development
```bash
docker-compose up --build
```

### Production Deployment
```bash
# Build and deploy
docker build -t {name.lower().replace('_', '-')} .
kubectl apply -f k8s/
```

## Health Endpoints

- `GET /health` - Liveness probe (Kubernetes compatible)
- `GET /ready` - Readiness probe (Kubernetes compatible)
- `GET /metrics` - Prometheus metrics

## Project Structure

```
{name}/
├── app.py              # Main microservice application
├── .env                # Environment variables
├── requirements.txt    # Python dependencies
├── Dockerfile          # Container image
├── docker-compose.yml  # Local development stack
├── k8s/               # Kubernetes manifests
│   └── deployment.yaml
└── README.md          # This file
```

## Configuration

### Environment Variables
- `SERVICE_NAME` - Service identifier
- `SERVICE_VERSION` - Service version
- `DATABASE_URL` - PostgreSQL connection string
- `REDIS_URL` - Redis connection string
- `METRICS_ENABLED` - Enable/disable metrics collection

### Kubernetes Secrets
```bash
kubectl create secret generic {name.lower().replace('_', '-')}-secrets \\
  --from-literal=database-url="postgresql://user:pass@host:5432/db" \\
  --from-literal=secret-key="your-secret-key"
```

## Monitoring

- **Health**: `/health` and `/ready` endpoints
- **Metrics**: `/metrics` for Prometheus scraping
- **Logs**: Structured JSON logging to stdout

## Next Steps

- Implement your business logic
- Configure database models and migrations
- Add authentication and authorization
- Set up monitoring and alerting
- Configure CI/CD pipeline

## Learn More

- [Zenith Documentation](https://zenith-python.org)
- [Microservice Examples](https://zenith-python.org/examples/microservice)
- [Kubernetes Deployment Guide](https://zenith-python.org/guides/kubernetes)
'''

    return [
        ("app.py", app_py_content),
        (".env", env_content),
        ("requirements.txt", requirements_content),
        ("Dockerfile", dockerfile_content),
        ("docker-compose.yml", docker_compose_content),
        ("k8s/deployment.yaml", k8s_deployment_content),
        (".gitignore", gitignore_content),
        ("README.md", readme_content),
    ]


@main.command()
@click.argument("path", default=".")
@click.option("--name", help="Application name")
def new(path: str, name: str | None):
    """Create a new Zenith application with best practices."""
    import secrets

    project_path = Path(path).resolve()

    if not name:
        name = project_path.name

    click.echo(f"🚀 Creating new Zenith app: {name}")
    click.echo(f"📁 Path: {project_path}")

    # Create project directory
    project_path.mkdir(exist_ok=True)

    # Generate secure secret key (64 bytes for stronger entropy)
    secret_key = secrets.token_urlsafe(64)

    # Create main app.py
    app_py_content = f'''"""
{name} - Zenith API application.
"""

from zenith import Zenith

# Create your Zenith app
app = Zenith()


@app.get("/")
async def root():
    """API root endpoint."""
    return {{"message": "Welcome to {name} API!", "status": "running"}}


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {{"status": "healthy", "service": "{name}"}}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000, reload=True)
'''

    # Create .env file
    env_content = f'''# Environment variables for {name}
SECRET_KEY={secret_key}
DEBUG=true

# Database (uncomment and configure as needed)
# DATABASE_URL=sqlite:///./app.db

# Redis (uncomment if using caching/sessions)
# REDIS_URL=redis://localhost:6379
'''

    # Create requirements.txt
    requirements_content = '''zenith-web>=0.3.0
uvicorn[standard]>=0.20.0
'''

    # Create .gitignore
    gitignore_content = '''# Python
__pycache__/
*.py[cod]
*.so
.Python
.venv/
venv/
ENV/

# Environment
.env
.env.local

# Database
*.db
*.sqlite

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
'''

    # Create README.md
    readme_content = f'''# {name}

A modern API built with [Zenith](https://zenith-python.org).

## Quick Start

1. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

2. Start development server:
   ```bash
   zen dev
   ```

3. Visit http://localhost:8000 to see your API!

## API Endpoints

- `GET /` - API root
- `GET /health` - Health check
- `GET /docs` - Interactive API documentation

## Project Structure

- `app.py` - Main application file
- `.env` - Environment variables (configure your secrets here)
- `requirements.txt` - Python dependencies

## Next Steps

- Add your business logic and models
- Configure database connection in `.env`
- Add authentication with `app.add_auth()`
- Deploy to production

## Learn More

- [Zenith Documentation](https://zenith-python.org)
- [API Examples](https://zenith-python.org/examples)
'''

    # Write all files
    files_to_create = [
        ("app.py", app_py_content),
        (".env", env_content),
        ("requirements.txt", requirements_content),
        (".gitignore", gitignore_content),
        ("README.md", readme_content),
    ]

    for filename, content in files_to_create:
        file_path = project_path / filename
        file_path.write_text(content.strip())
        click.echo(f"  ✓ {filename}")

    click.echo("\n✅ Project created successfully!")
    click.echo("\nNext steps:")
    click.echo(f"  cd {project_path.name}")
    click.echo("  pip install -r requirements.txt")
    click.echo("  zen dev                         # Start development server")


@main.command("dev")
@click.option("--host", "-h", default="127.0.0.1", help="Host to bind to")
@click.option("--port", "-p", default=8000, type=int, help="Port to bind to")
@click.option("--app", default=None, help="Import path to app (e.g., src.api.app:app)")
@click.option("--open", is_flag=True, help="Open browser after start")
@click.option("--testing", is_flag=True, help="Enable testing mode (disables rate limiting)")
def dev(host: str, port: int, app: str | None, open: bool, testing: bool):
    """Start development server with hot reload."""
    if testing:
        import os
        os.environ["ZENITH_ENV"] = "test"
        click.echo("🧪 Testing mode enabled - rate limiting and other test-interfering middleware disabled")

    _run_server(host, port, reload=True, workers=1, open_browser=open, app_path=app)


@main.command("serve")
@click.option("--host", "-h", default="0.0.0.0", help="Host to bind to")
@click.option("--port", "-p", default=8000, type=int, help="Port to bind to")
@click.option("--workers", "-w", default=4, type=int, help="Number of workers")
@click.option("--reload", is_flag=True, help="Enable reload (development)")
def serve(host: str, port: int, workers: int, reload: bool):
    """Start production server."""
    _run_server(host, port, reload=reload, workers=workers)


def _run_server(host: str, port: int, reload: bool = False, workers: int = 1, open_browser: bool = False, app_path: str | None = None):
    """Internal function to run uvicorn server."""
    import importlib.util
    import os

    # Enhanced app discovery
    app_module = None
    app_var = "app"

    # Strategy 0: Use explicit app path if provided
    if app_path:
        if ':' in app_path:
            app_module, app_var = app_path.split(':', 1)
        else:
            app_module = app_path
            app_var = "app"
        click.echo(f"🎯 Using explicit app path: {app_module}:{app_var}")
    else:
        # Strategy 1: Check for common app files and discover app variable
        discovery_patterns = [
            ("app.py", "app"),
            ("main.py", "app"),
            ("application.py", "app"),
            ("application.py", "application"),
        ]

        for filename, var_name in discovery_patterns:
            if Path(filename).exists():
                # Try to discover the actual app variable by importing the module
                try:
                    module_name = filename.replace(".py", "")
                    spec = importlib.util.spec_from_file_location(module_name, filename)
                    if spec and spec.loader:
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)

                        # Check if the expected variable exists and is a Zenith app
                        if hasattr(module, var_name):
                            attr = getattr(module, var_name)
                            if hasattr(attr, '__class__') and 'Zenith' in str(type(attr)):
                                app_module = module_name
                                app_var = var_name
                                break
                            # Also try to find any Zenith app in the module
                            for attr_name in dir(module):
                                if not attr_name.startswith('_'):
                                    attr = getattr(module, attr_name)
                                    if hasattr(attr, '__class__') and 'Zenith' in str(type(attr)):
                                        app_module = module_name
                                        app_var = attr_name
                                        break
                        if app_module:
                            break
                except Exception:
                    # If import fails, fall back to filename-based discovery
                    app_module = filename.replace(".py", "")
                    break

    # Strategy 2: Look for nested app structures (like src/api/app.py)
    if not app_module:
        common_paths = [
            "src/app.py",
            "src/api/app.py",
            "src/main.py",
            "app/main.py",
            "api/app.py"
        ]

        for path_str in common_paths:
            path = Path(path_str)
            if path.exists():
                try:
                    # Convert path to module notation: src/api/app.py -> src.api.app
                    module_path = str(path.with_suffix('')).replace('/', '.')
                    spec = importlib.util.spec_from_file_location(module_path.split('.')[-1], path)
                    if spec and spec.loader:
                        module = importlib.util.module_from_spec(spec)
                        # Add the parent directory to sys.path temporarily
                        parent_dir = str(path.parent.parent.absolute()) if len(path.parts) > 1 else str(Path.cwd())
                        if parent_dir not in sys.path:
                            sys.path.insert(0, parent_dir)

                        spec.loader.exec_module(module)

                        if hasattr(module, 'app'):
                            attr = getattr(module, 'app')
                            if hasattr(attr, '__class__') and 'Zenith' in str(type(attr)):
                                app_module = module_path
                                app_var = 'app'
                                break
                except Exception:
                    continue

    if not app_module:
        click.echo("❌ No Zenith app found")
        click.echo("")
        click.echo("🔍 Searched for:")
        click.echo("   • app.py, main.py, application.py (with 'app' variable)")
        click.echo("   • src/app.py, src/api/app.py, src/main.py")
        click.echo("   • app/main.py, api/app.py")
        click.echo("")
        click.echo("💡 Quick solutions:")
        click.echo("   1. Specify explicitly: zen dev --app=my_module:app")
        click.echo("   2. Create main.py: from src.api.app import app")
        click.echo("   3. Generate new app: zen new .")
        click.echo("")
        click.echo("🧪 For testing: zen dev --testing --app=your.module:app")
        click.echo("")
        click.echo("📁 Current directory contents:")
        cwd = Path.cwd()
        py_files = list(cwd.glob("*.py"))
        if py_files:
            for py_file in py_files[:5]:  # Show up to 5 Python files
                click.echo(f"   • {py_file.name}")
            if len(py_files) > 5:
                click.echo(f"   • ... and {len(py_files) - 5} more .py files")
        else:
            click.echo("   • No .py files found")

        subdirs_with_py = []
        for subdir in ["src", "app", "api"]:
            subdir_path = cwd / subdir
            if subdir_path.exists() and subdir_path.is_dir():
                py_files_in_subdir = list(subdir_path.glob("*.py"))
                if py_files_in_subdir:
                    subdirs_with_py.append(f"{subdir}/ ({len(py_files_in_subdir)} .py files)")

        if subdirs_with_py:
            click.echo("   Subdirectories with Python files:")
            for subdir_info in subdirs_with_py:
                click.echo(f"   • {subdir_info}")

        sys.exit(1)

    if reload:
        click.echo("🔧 Starting Zenith development server...")
        click.echo("🔄 Hot reload enabled - edit files to see changes instantly!")
        cmd = [
            "uvicorn",
            f"{app_module}:{app_var}",
            f"--host={host}",
            f"--port={port}",
            "--reload",
            "--reload-include=*.py",
            "--reload-include=*.html",
            "--reload-include=*.css",
            "--reload-include=*.js",
            "--log-level=info",
        ]
    else:
        click.echo("🚀 Starting Zenith production server...")
        click.echo(f"👥 Workers: {workers}")
        cmd = [
            "uvicorn",
            f"{app_module}:{app_var}",
            f"--host={host}",
            f"--port={port}",
            f"--workers={workers}",
            "--log-level=info",
            "--access-log",
        ]

    click.echo(f"🌐 Server:  http://{host}:{port}")
    click.echo(f"📖 Docs:    http://{host}:{port}/docs")
    click.echo(f"❤️ Health:  http://{host}:{port}/health")

    if open_browser:
        import webbrowser
        webbrowser.open(f"http://{host}:{port}")

    try:
        subprocess.run(cmd)
    except KeyboardInterrupt:
        click.echo("\n👋 Server stopped")


if __name__ == "__main__":
    main()
