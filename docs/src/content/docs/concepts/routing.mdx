---
title: Routing & Request Handling
description: Build type-safe, organized API endpoints with automatic validation
---

import { Aside } from '@astrojs/starlight/components';

## Routing Overview

As APIs grow, endpoint management can become complex:
- **Scattered routes** across multiple files with no clear organization
- **Manual validation** of query parameters, path variables, and request bodies
- **Type mismatches** between what you expect and what you receive
- **Manual validation** for parsing and serializing data
- **Inconsistent error handling** across different endpoints

<Aside type="caution">
  **Without proper routing:** A 50-endpoint API can have validation code scattered across 500+ lines, making bugs inevitable and maintenance painful.
</Aside>

## Type-Safe, Organized Routing

Zenith's routing system provides:
- **Decorator-based routing** - Clean, intuitive endpoint definition
- **Automatic validation** - Pydantic models validate all inputs
- **Type safety** - Full IDE support with autocomplete
- **Router organization** - Group related endpoints together
- **Minimal configuration** - Focus on business logic

## When to Use Different Routing Patterns

| Use Case | Pattern | Example |
|----------|---------|----------|
| Simple APIs | Flat routing | `@app.get("/users")` |
| Large APIs | Router groups | `users_router = Router()` |
| Microservices | Versioned routes | `/api/v1/users` |
| Multi-tenant | Prefix routing | `/{tenant}/users` |
| File serving | Path matching | `/{file_path:path}` |

## Quick Example

See how Zenith eliminates boilerplate validation code:

```python
# Before: Manual validation nightmare (what you'd write without Zenith)
async def get_users(request):
    # Step 1: Manually extract query parameter
    page = request.query_params.get('page', '1')

    # Step 2: Try to convert to integer
    try:
        page = int(page)
        # Step 3: Validate the value
        if page < 1:
            return JSONResponse({"error": "Invalid page"}, 400)
    except ValueError:
        # Step 4: Handle conversion errors
        return JSONResponse({"error": "Page must be integer"}, 400)

    # Step 5: Repeat for EVERY parameter...
    limit = request.query_params.get('limit', '10')
    # ... 10+ more lines of validation per parameter ...

# After: Zenith automatic validation
@app.get("/users")
async def get_users(page: int = 1, limit: int = 10):
    # That's it! Zenith handles:
    # - Extracting 'page' and 'limit' from query string
    # - Converting to int type
    # - Applying defaults if missing
    # - Returning 422 error if validation fails
    return await fetch_users(page, limit)
```

## Core Concepts

### 1. Route Definition

Zenith provides an intuitive decorator-based routing system with full type safety.

### Basic Routes

```python
from zenith import Zenith

app = Zenith()

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.post("/items")
async def create_item(item: dict):
    return {"created": item}

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: dict):
    return {"updated": item_id, "data": item}

@app.delete("/items/{item_id}")
async def delete_item(item_id: int):
    return {"deleted": item_id}
```

### Path Parameters

Extract values directly from the URL path:

```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):  # Type hint enforces integer
    # URL: /users/123     -> user_id = 123 ✅
    # URL: /users/alice   -> 422 error (not an integer) ❌
    return {"user_id": user_id}

@app.get("/posts/{year}/{month}/{slug}")
async def get_post(year: int, month: int, slug: str):
    # URL: /posts/2024/03/my-post
    # Extracts: year=2024, month=3, slug="my-post"
    return {"year": year, "month": month, "slug": slug}

@app.get("/files/{file_path:path}")
async def get_file(file_path: str):
    # Special :path converter captures everything including slashes
    # URL: /files/documents/2024/report.pdf
    # Captures: file_path = "documents/2024/report.pdf"
    return {"file": file_path}
```

### Query Parameters

Extract values from the URL query string (after the ?):

```python
from typing import Optional

@app.get("/search")
async def search(
    q: str,                      # Required (no default value)
    limit: int = 10,             # Optional with default
    offset: int = 0,             # Optional with default
    sort: Optional[str] = None   # Optional, can be None
):
    # URL: /search?q=python
    #   -> q="python", limit=10, offset=0, sort=None
    #
    # URL: /search?q=python&limit=5&sort=date
    #   -> q="python", limit=5, offset=0, sort="date"
    #
    # URL: /search   (missing required 'q')
    #   -> 422 validation error

    return {
        "query": q,
        "limit": limit,
        "offset": offset,
        "sort": sort
    }
```

## Request Bodies

### With Pydantic Models

```python
from pydantic import BaseModel
from datetime import datetime

class PostCreate(BaseModel):
    title: str
    content: str
    published: bool = False
    tags: list[str] = []

@app.post("/posts")
async def create_post(post: PostCreate):
    # Automatic validation and parsing
    return {"created": post.model_dump()}
```

### File Uploads

```python
from zenith import UploadFile, File

@app.post("/upload")
async def upload_file(file: UploadFile = File()):
    contents = await file.read()
    return {
        "filename": file.filename,
        "size": len(contents),
        "content_type": file.content_type
    }

@app.post("/upload-multiple")
async def upload_multiple(files: list[UploadFile] = File()):
    return {
        "uploaded": [f.filename for f in files]
    }
```

## Response Models

```python
class PostResponse(BaseModel):
    id: int
    title: str
    content: str
    author: str
    created_at: datetime
    tags: list[str]

@app.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int) -> PostResponse:
    # Return value is automatically validated and serialized
    return PostResponse(
        id=post_id,
        title="Example Post",
        content="Content here",
        author="Alice",
        created_at=datetime.utcnow(),
        tags=["example"]
    )
```

## Common Patterns

### API Versioning

```python
# Versioned API structure
v1_router = Router(prefix="/api/v1")
v2_router = Router(prefix="/api/v2")

@v1_router.get("/users")
async def get_users_v1():
    # V1 implementation
    return {"version": "1.0", "users": []}

@v2_router.get("/users")
async def get_users_v2():
    # V2 with pagination
    return {
        "version": "2.0",
        "users": [],
        "pagination": {"page": 1, "total": 0}
    }

app.include_router(v1_router)
app.include_router(v2_router)
```

### RESTful CRUD Pattern

```python
from zenith import Router, HTTPException
from typing import List

router = Router(prefix="/api/items", tags=["Items"])

@router.get("/", response_model=List[Item])
async def list_items(skip: int = 0, limit: int = 100):
    """List all items with pagination."""
    return await get_items(skip, limit)

@router.get("/{item_id}", response_model=Item)
async def get_item(item_id: int):
    """Get a single item by ID."""
    item = await find_item(item_id)
    if not item:
        raise HTTPException(404, "Item not found")
    return item

@router.post("/", response_model=Item, status_code=201)
async def create_item(item: ItemCreate):
    """Create a new item."""
    return await save_item(item)

@router.put("/{item_id}", response_model=Item)
async def update_item(item_id: int, item: ItemUpdate):
    """Update an existing item."""
    return await modify_item(item_id, item)

@router.delete("/{item_id}", status_code=204)
async def delete_item(item_id: int):
    """Delete an item."""
    await remove_item(item_id)
```

### Multi-tenant Routing

```python
@app.get("/{tenant_id}/dashboard")
async def tenant_dashboard(
    tenant_id: str,
    user = Depends(get_current_user)
):
    # Verify user has access to tenant
    if not user.has_tenant_access(tenant_id):
        raise HTTPException(403, "Access denied")

    return await get_tenant_data(tenant_id)
```

## Router Organization

### Creating Routers

```python
# routes/users.py
from zenith import Router

router = Router(prefix="/users", tags=["Users"])

@router.get("/")
async def list_users():
    return {"users": []}

@router.get("/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}

@router.post("/")
async def create_user(user: dict):
    return {"created": user}
```

### Including Routers

```python
# main.py
from zenith import Zenith
from routes import users, posts, auth

app = Zenith()

# Include routers
app.include_router(users.router)
app.include_router(posts.router)
app.include_router(auth.router, prefix="/api/auth")
```

### Nested Routers

```python
# Create parent router
api_router = Router(prefix="/api/v1")

# Create child routers
users_router = Router(prefix="/users", tags=["Users"])
posts_router = Router(prefix="/posts", tags=["Posts"])

# Include child routers in parent
api_router.include_router(users_router)
api_router.include_router(posts_router)

# Include parent in app
app.include_router(api_router)
```

## Dependency Injection

```python
from zenith import Depends

async def get_db():
    """Database dependency."""
    db = DatabaseSession()
    try:
        yield db
    finally:
        await db.close()

async def get_current_user(token: str = Header()):
    """Extract user from token."""
    user = decode_token(token)
    if not user:
        raise HTTPException(401, "Invalid token")
    return user

@app.get("/protected")
async def protected_route(
    user = Depends(get_current_user),
    db = Depends(get_db)
):
    # Dependencies are automatically injected
    return {"user": user, "db_connected": True}
```

## Route Configuration

### Status Codes

```python
@app.post("/items", status_code=201)
async def create_item(item: dict):
    return {"created": item}

@app.delete("/items/{item_id}", status_code=204)
async def delete_item(item_id: int):
    # No content returned
    pass
```

### Tags and Documentation

```python
@app.get(
    "/users",
    tags=["Users"],
    summary="List all users",
    description="""
    Retrieve a paginated list of all users.
    Requires authentication.
    """,
    response_description="List of users"
)
async def list_users():
    return {"users": []}
```

### Custom Responses

```python
from zenith import JSONResponse, HTMLResponse, FileResponse

@app.get("/json")
async def json_response():
    return JSONResponse(
        content={"message": "Custom JSON"},
        status_code=200,
        headers={"X-Custom": "Header"}
    )

@app.get("/html")
async def html_response():
    return HTMLResponse(
        content="<h1>Hello World</h1>",
        status_code=200
    )

@app.get("/download")
async def download_file():
    return FileResponse(
        path="/path/to/file.pdf",
        filename="document.pdf",
        media_type="application/pdf"
    )
```

## Advanced Routing

### Route Priority

```python
# More specific routes should be defined first
@app.get("/users/me")
async def get_current_user():
    return {"user": "current"}

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}
```

### Regex Patterns

```python
@app.get("/items/{item_id:^[0-9]+$}")
async def get_item_numeric(item_id: str):
    # Only matches numeric IDs
    return {"item_id": int(item_id)}

@app.get("/items/{item_id:^[a-z]+$}")
async def get_item_alpha(item_id: str):
    # Only matches alphabetic IDs
    return {"item_id": item_id}
```

### Wildcard Routes

```python
@app.get("/{full_path:path}")
async def catch_all(full_path: str):
    # Catches all unmatched routes
    return {"path": full_path, "message": "Not found"}
```

<Aside type="tip">
  **Best Practice**: Organize routes by feature in separate router modules. This keeps your codebase maintainable as it grows.
</Aside>

## WebSocket Routes

```python
from zenith import WebSocket

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Echo: {data}")
```

## Best Practices

###  DO
- **Group related endpoints** in router modules
- **Use consistent naming** (plural for collections, singular for items)
- **Version your API** from the start (`/api/v1/`)
- **Return proper status codes** (201 for creation, 204 for deletion)
- **Document endpoints** with docstrings and OpenAPI metadata
- **Validate everything** with Pydantic models

### ❌ DON'T
- Don't mix business logic in route handlers
- Don't use generic exception messages
- Don't forget to handle edge cases (404, 409, etc.)
- Don't expose internal errors to clients
- Don't use synchronous operations in async routes

## Troubleshooting

### Common Issues

**"Route not found (404)"**
- Check route registration order (specific before generic)
- Verify router is included in app
- Check for typos in path parameters

**"Validation error"**
- Ensure request body matches Pydantic model
- Check required vs optional fields
- Verify type annotations are correct

**"Method not allowed (405)"**
- Verify HTTP method matches decorator
- Check if route supports the method

**"Depends() not working"**
- Import from `zenith` not `fastapi`
- Ensure dependency returns/yields value
- Check async vs sync consistency

### Debugging Routes

```python
# List all routes
for route in app.routes:
    print(f"{route.methods} {route.path}")

# Test route matching
from zenith.testing import TestClient

async with TestClient(app) as client:
    response = await client.get("/api/users")
    print(f"Status: {response.status_code}")
    print(f"Body: {response.json()}")
```

## Performance Tips

1. **Use path parameters for IDs** - Faster than query params
   ```python
   # Good: O(1) lookup
   @app.get("/users/{user_id}")

   # Slower: Requires parsing
   @app.get("/users?id={user_id}")
   ```

2. **Limit query results** - Always paginate
   ```python
   @app.get("/items")
   async def list_items(limit: int = 100):
       if limit > 1000:
           limit = 1000  # Cap maximum
   ```

3. **Cache route handlers** - For expensive operations
   ```python
   from zenith.cache import cached

   @app.get("/stats")
   @cached(ttl=60)  # Cache for 1 minute
   async def get_stats():
       return await calculate_expensive_stats()
   ```

## Testing Routes

```python
from zenith.testing import TestClient

async def test_routes():
    async with TestClient(app) as client:
        # Test GET
        response = await client.get("/")
        assert response.status_code == 200
        
        # Test POST
        response = await client.post(
            "/items",
            json={"name": "Test Item"}
        )
        assert response.status_code == 201
        
        # Test with headers
        response = await client.get(
            "/protected",
            headers={"Authorization": "Bearer token"}
        )
        assert response.status_code == 200
```

## Migration Guide

### From Flask
```python
# Flask
@app.route('/users/<int:user_id>', methods=['GET', 'POST'])
def user_detail(user_id):
    if request.method == 'POST':
        data = request.get_json()
        # manual validation
    return jsonify({"user_id": user_id})

# Zenith
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}

@app.post("/users/{user_id}")
async def update_user(user_id: int, data: UserUpdate):
    # Automatic validation!
    return {"updated": user_id}
```

### From FastAPI
```python
# FastAPI - Almost identical!
# Main difference: Zenith has automatic setup
from fastapi import FastAPI, Depends
app = FastAPI()

# Zenith - Cleaner imports, same power
from zenith import Zenith
app = Zenith()  # Auto-configures everything
```

### From Express.js
```javascript
// Express.js
app.get('/users/:id', (req, res) => {
  const id = parseInt(req.params.id);
  if (isNaN(id)) {
    return res.status(400).json({error: 'Invalid ID'});
  }
  res.json({user_id: id});
});
```

```python
# Zenith
@app.get("/users/{user_id}")
async def get_user(user_id: int):  # Auto-validates int!
    return {"user_id": user_id}
```

## Related Topics

- **[Middleware](/zenith/concepts/middleware/)** - Process requests before routes
- **[Authentication](/zenith/concepts/authentication/)** - Secure your endpoints
- **[Models](/zenith/concepts/models/)** - Database integration
- **[Services](/zenith/concepts/services/)** - Organize business logic
- **[Testing](/zenith/api/testing/)** - Test your routes

## Next Steps

- Try the **[Basic Routing Example](/zenith/examples/basic-routing/)**
- Build a **[Complete API](/zenith/examples/blog-api/)**
- Learn about **[Router Organization](/zenith/examples/auto-generated/15-router-grouping/)**

---

*Learn more in the [API Reference](/zenith/api/router/) or explore [routing examples](/zenith/examples/basic-routing/).*