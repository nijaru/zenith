---
title: Database Models - SQLModel Enhanced
description: Zenith's enhanced SQLModel patterns for clean, type-safe database operations
---

import { Aside } from '@astrojs/starlight/components';

## ZenithModel - Rails-like Database Models

Zenith provides `ZenithModel` - a Rails-inspired base class that adds chainable queries, automatic session management, and enhanced developer experience to SQLModel.

<Aside type="note">
  **ZenithModel** combines SQLModel's type safety with Rails-like ActiveRecord patterns for ultimate productivity.
</Aside>

## Why ZenithModel?

### Traditional SQLModel Approach

```python
# Standard SQLModel requires manual session management
from sqlmodel import SQLModel, Field, select
from sqlalchemy.ext.asyncio import AsyncSession

class User(SQLModel, table=True):
    id: int | None = Field(primary_key=True)
    name: str
    email: str

# Manual session management required
async def get_users(session: AsyncSession):
    stmt = select(User).where(User.active == True).order_by(User.created_at.desc()).limit(10)
    result = await session.execute(stmt)
    return result.scalars().all()
    )

    id: int | None = Field(primary_key=True)
    name: str = Field(max_length=100)
    email: str = Field(unique=True)
```

### ZenithModel Approach (Rails-like DX)

```python
# ZenithModel provides Rails-like patterns with automatic session management
from zenith.db import ZenithModel
from sqlmodel import Field

class User(ZenithModel, table=True):
    id: int | None = Field(primary_key=True)
    name: str = Field(max_length=100)
    email: str = Field(unique=True)
    active: bool = Field(default=True)

# Rails-like chainable queries - no manual session needed!
async def get_users():
    return await User.where(active=True).order_by('-created_at').limit(10)
```

## Creating Models

### Basic Model

```python
from zenith import Model
from sqlmodel import Field
from datetime import datetime
from typing import Optional

class User(ZenithModel, table=True):
    """User model with enhanced configuration."""

    id: Optional[int] = Field(primary_key=True)
    name: str = Field(max_length=100)
    email: str = Field(unique=True, index=True)
    active: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Model with Relationships

```python
from sqlmodel import Relationship

class Post(ZenithModel, table=True):
    """Blog post model."""

    id: Optional[int] = Field(primary_key=True)
    title: str = Field(max_length=200)
    content: str
    author_id: int = Field(foreign_key="user.id")
    published: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)

class Comment(ZenithModel, table=True):
    """Comment model."""

    id: Optional[int] = Field(primary_key=True)
    content: str
    post_id: int = Field(foreign_key="post.id")
    author_id: int = Field(foreign_key="user.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

## Database Operations with Zenith

### Using with Enhanced Dependency Injection

```python
from zenith import Zenith
from zenith.core import DB
from zenith.db import ZenithModel
from sqlmodel import select, and_

app = Zenith()

@app.get("/users")
async def get_users(active: bool = True, db=Session):
    """Get users with clean dependency injection."""
    async with db() as session:
        # Type-safe SQLModel queries
        result = await session.execute(
            select(User)
            .where(User.active == active)
            .order_by(User.created_at.desc())
            .limit(10)
        )
        users = result.scalars().all()
        return {"users": [user.model_dump() for user in users]}

@app.post("/users")
async def create_user(user_data: dict, db=Session):
    """Create user with automatic session management."""
    async with db() as session:
        user = User(**user_data)
        session.add(user)
        await session.commit()
        await session.refresh(user)
        return {"user": user.model_dump()}
```

### Advanced Queries

```python
@app.get("/posts")
async def get_posts(author_id: int | None = None, db=Session):
    """Advanced querying with joins and filtering."""
    async with db() as session:
        query = select(Post)

        if author_id:
            query = query.where(Post.author_id == author_id)

        # Join with user for author information
        query = query.join(User).where(User.active == True)

        result = await session.execute(query)
        posts = result.scalars().all()

        return {"posts": [post.model_dump() for post in posts]}
```

## Model Configuration

### Enhanced Defaults

The Zenith `Model` base class provides these enhanced defaults automatically:

```python
class Model(SQLModel):
    """
    Recommended base class for database models.

    A clean alias for SQLModel with sensible defaults for most use cases.
    """
    model_config = ConfigDict(
        from_attributes=True,      # Allow ORM object conversion
        use_enum_values=True,      # Serialize enums as values
        validate_assignment=True,  # Validate on assignment
    )
```

### Custom Model Base

```python
from zenith import Model
from datetime import datetime
from sqlmodel import Field

class BaseModel(Model):
    """Custom base model with common fields."""

    id: int | None = Field(primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class User(BaseModel, table=True):
    """User inherits common fields."""
    name: str
    email: str
    active: bool = Field(default=True)

class Post(BaseModel, table=True):
    """Post inherits common fields."""
    title: str
    content: str
    author_id: int = Field(foreign_key="user.id")
```

## Validation and Serialization

### Model Validation

```python
from pydantic import validator, EmailStr

class User(ZenithModel, table=True):
    name: str = Field(min_length=2, max_length=100)
    email: EmailStr = Field(unique=True)
    age: int = Field(ge=13, le=120)

    @validator('name')
    def validate_name(cls, v):
        """Custom name validation."""
        if not v.replace(' ', '').isalpha():
            raise ValueError('Name must contain only letters and spaces')
        return v.title()

    @validator('email')
    def validate_email_domain(cls, v):
        """Custom email validation."""
        allowed_domains = ['company.com', 'partner.org']
        domain = v.split('@')[1]
        if domain not in allowed_domains:
            raise ValueError(f'Email domain must be one of: {allowed_domains}')
        return v
```

### Serialization

```python
class User(ZenithModel, table=True):
    id: int | None = Field(primary_key=True)
    name: str
    email: str
    password_hash: str = Field(exclude=True)  # Never serialize passwords
    created_at: datetime

    def to_public_dict(self) -> dict:
        """Public-safe serialization."""
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'created_at': self.created_at.isoformat()
        }

# Usage in routes
@app.get("/users/{user_id}")
async def get_user(user_id: int, db=Session):
    async with db() as session:
        result = await session.execute(select(User).where(User.id == user_id))
        user = result.scalar_one_or_none()

        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        return user.to_public_dict()
```

## Testing Models

### Model Testing with TestClient

```python
import pytest
from zenith.testing import TestClient

@pytest.mark.asyncio
async def test_user_creation():
    """Test user creation endpoint."""
    async with TestClient(app) as client:
        response = await client.post("/users", json={
            "name": "Test User",
            "email": "test@example.com",
            "age": 25
        })

        assert response.status_code == 201
        user_data = response.json()["user"]
        assert user_data["name"] == "Test User"
        assert user_data["email"] == "test@example.com"

@pytest.mark.asyncio
async def test_user_validation():
    """Test model validation."""
    async with TestClient(app) as client:
        # Test invalid email
        response = await client.post("/users", json={
            "name": "Test User",
            "email": "invalid-email",
            "age": 25
        })

        assert response.status_code == 422
        assert "email" in response.json()["detail"][0]["loc"]
```

### Direct Model Testing

```python
@pytest.mark.asyncio
async def test_model_validation():
    """Test model validation directly."""
    # Valid user
    user = User(name="John Doe", email="john@company.com", age=30)
    assert user.name == "John Doe"

    # Invalid email domain
    with pytest.raises(ValueError, match="Email domain must be"):
        User(name="Jane", email="jane@invalid.com", age=25)

    # Invalid age
    with pytest.raises(ValueError):
        User(name="Bob", email="bob@company.com", age=12)
```

## Production Patterns

### Service Layer Integration

```python
from zenith.core import DB, Inject

class UserService(Service):
    """Business logic for user operations."""

    async def create_user(self, user_data: dict, db=Session) -> User:
        """Create user with business logic."""
        async with db() as session:
            # Business logic validation
            if await self.email_exists(user_data['email'], session):
                raise ValueError("Email already exists")

            # Create user
            user = User(**user_data)
            session.add(user)
            await session.commit()
            await session.refresh(user)

            # Send welcome email (example)
            await self.send_welcome_email(user.email)

            return user

    async def email_exists(self, email: str, session) -> bool:
        """Check if email already exists."""
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none() is not None

# Usage in routes
@app.post("/users")
async def create_user(
    user_data: dict,
    users: UserService = Inject(),
    db=Session
):
    user = await users.create_user(user_data, db)
    return {"user": user.to_public_dict()}
```

### Repository Pattern

```python
from sqlmodel import select, and_, or_

class UserRepository:
    """Data access layer for users."""

    def __init__(self, session):
        self.session = session

    async def find_by_id(self, user_id: int) -> User | None:
        """Find user by ID."""
        result = await self.session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()

    async def find_active_users(self, limit: int = 10) -> list[User]:
        """Find active users."""
        result = await self.session.execute(
            select(User)
            .where(User.active == True)
            .order_by(User.created_at.desc())
            .limit(limit)
        )
        return list(result.scalars().all())

    async def search_users(self, query: str) -> list[User]:
        """Search users by name or email."""
        search_pattern = f"%{query}%"
        result = await self.session.execute(
            select(User).where(
                or_(
                    User.name.ilike(search_pattern),
                    User.email.ilike(search_pattern)
                )
            )
        )
        return list(result.scalars().all())

# Usage with dependency injection
@app.get("/users/search")
async def search_users(q: str, db=Session):
    async with db() as session:
        repo = UserRepository(session)
        users = await repo.search_users(q)
        return {"users": [user.to_public_dict() for user in users]}
```

## Best Practices

<Aside type="tip" title="Model Best Practices">
  1. **Use Zenith Model** - Enhanced configuration and better defaults
  2. **Type safety** - Full type hints with Union types, datetime, etc.
  3. **Validation** - Use Pydantic validators for data integrity
  4. **Separation of concerns** - Keep business logic in services
  5. **Repository pattern** - Separate data access from business logic
</Aside>

### Do's ✅

- Use the `Model` base class for enhanced configuration
- Implement custom validation with Pydantic validators
- Use the `Session` dependency for clean database access
- Separate business logic into service classes
- Create repository classes for complex queries
- Use type hints throughout your models

### Don'ts ❌

- Don't put business logic in model classes
- Don't serialize sensitive data (passwords, tokens)
- Don't forget to handle None values appropriately
- Don't mix database queries with route handlers
- Don't ignore validation errors
- Don't use raw SQL unless absolutely necessary

## Migration from Standard SQLModel

### Before (Standard SQLModel)

```python
from sqlmodel import SQLModel, Field
from pydantic import ConfigDict

class User(SQLModel, table=True):
    # Manual configuration required
    model_config = ConfigDict(
        from_attributes=True,
        use_enum_values=True,
        validate_assignment=True,
    )

    id: int | None = Field(primary_key=True)
    name: str
    email: str
```

### After (Zenith Model)

```python
from zenith import Model
from sqlmodel import Field

class User(ZenithModel, table=True):
    # Enhanced configuration provided automatically
    id: int | None = Field(primary_key=True)
    name: str
    email: str
```

## Next Steps

- Learn about [Enhanced Dependency Injection](./services)
- Explore [Database Relationships](./database)
- See [API Testing](../api/testing) with Zenith Models
- Check out [Real-world Examples](https://github.com/nijaru/zenith/tree/main/examples)

---

**Enhanced SQLModel patterns** - Zenith's Model base class provides better defaults and cleaner patterns for modern Python applications! 🎉