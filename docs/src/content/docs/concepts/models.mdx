---
title: Database Models
description: Type-safe database operations with automatic session management
---

import { Aside } from '@astrojs/starlight/components';

## Database Model Overview

Traditional ORMs require manual session management, explicit transaction handling, and verbose query syntax. This leads to repetitive setup code that obscures your actual business logic.

<Aside type="caution">
  **Without ZenithModel:** Every query needs session management, transaction handling, and result processing - turning simple operations into 10+ lines of code.
</Aside>

## ZenithModel

ZenithModel simplifies database operations with:
- **Automatic session management** - No more `async with session()` blocks
- **Chainable queries** - Intuitive `User.where().order_by().limit()` patterns
- **Built-in CRUD methods** - `create()`, `find()`, `update()`, `delete()`
- **Type safety** - Full IDE support and type checking
- **Automatic configuration** - Just inherit and use

## When to Use ZenithModel

| Use ZenithModel When | Use Plain SQLModel When |
|---------------------|------------------------|
| Building typical web APIs | Need fine-grained transaction control |
| Want automatic session management | Working with multiple databases |
| Need rapid development | Implementing complex stored procedures |
| Standard CRUD operations | Raw SQL performance optimization |
| Request-scoped sessions work | Need connection pooling customization |

## Quick Example

```python
# Before: Traditional SQLModel (verbose)
async def get_active_users(session: AsyncSession):
    stmt = select(User).where(User.active == True).order_by(User.created_at.desc()).limit(10)
    result = await session.execute(stmt)
    return result.scalars().all()

# After: ZenithModel (clean)
async def get_active_users():
    return await User.where(active=True).order_by('-created_at').limit(10).all()
```

## Core Concepts

### 1. Define Your Model

```python
from zenith.db import ZenithModel
from sqlmodel import Field
from datetime import datetime

class User(ZenithModel, table=True):
    """User model with automatic session management."""

    id: int | None = Field(primary_key=True)
    email: str = Field(unique=True, index=True)
    name: str = Field(max_length=100)
    active: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2. Use Built-in Methods

```python
# Create
user = await User.create(
    email="alice@example.com",
    name="Alice Smith"
)

# Find
user = await User.find(1)  # Returns None if not found
user = await User.find_or_404(1)  # Raises 404 if not found

# Query
active_users = await User.where(active=True).all()
recent_users = await User.order_by('-created_at').limit(5).all()

# Update
await user.update(name="Alice Johnson")

# Delete
await user.delete()
```

### 3. Use in Routes

```python
from zenith import Zenith

app = Zenith()

@app.get("/users")
async def list_users():
    # No session management needed!
    users = await User.where(active=True).all()
    return {"users": [u.to_dict() for u in users]}

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    # Automatic 404 handling
    user = await User.find_or_404(user_id)
    return user.to_dict()

@app.post("/users")
async def create_user(data: UserCreate):
    # Simple creation
    user = await User.create(**data.model_dump())
    return {"user": user.to_dict()}, 201
```

## Common Patterns

### Pagination

```python
@app.get("/users")
async def list_users(page: int = 1, per_page: int = 20):
    offset = (page - 1) * per_page

    users = await User.where(active=True) \
        .order_by('-created_at') \
        .offset(offset) \
        .limit(per_page) \
        .all()

    total = await User.where(active=True).count()

    return {
        "users": [u.to_dict() for u in users],
        "page": page,
        "total": total,
        "pages": (total + per_page - 1) // per_page
    }
```

### Filtering

```python
@app.get("/users/search")
async def search_users(
    q: str = None,
    active: bool = None,
    role: str = None
):
    query = User.query()

    if q:
        query = query.where(User.name.contains(q) | User.email.contains(q))
    if active is not None:
        query = query.where(active=active)
    if role:
        query = query.where(role=role)

    users = await query.order_by('-created_at').all()
    return {"users": [u.to_dict() for u in users]}
```

### Relationships

```python
class Post(ZenithModel, table=True):
    id: int | None = Field(primary_key=True)
    title: str
    content: str
    author_id: int = Field(foreign_key="user.id")

    # Eager loading
    author: User = Relationship()

# Load with relationships
posts = await Post.includes('author').where(published=True).all()

# Access without N+1 queries
for post in posts:
    print(f"{post.title} by {post.author.name}")
```

### Bulk Operations

```python
# Bulk create
users = await User.bulk_create([
    {"email": "user1@example.com", "name": "User 1"},
    {"email": "user2@example.com", "name": "User 2"},
    {"email": "user3@example.com", "name": "User 3"},
])

# Bulk update
await User.where(role="trial").update_all(role="free")

# Bulk delete
await User.where(active=False, created_at__lt=thirty_days_ago).delete_all()
```

## Advanced Features

### Custom Validation

```python
from pydantic import validator, EmailStr

class User(ZenithModel, table=True):
    email: EmailStr = Field(unique=True)
    age: int = Field(ge=13, le=120)

    @validator('email')
    def validate_email_domain(cls, v):
        allowed = ['company.com', 'partner.org']
        domain = v.split('@')[1]
        if domain not in allowed:
            raise ValueError(f'Email domain must be one of: {allowed}')
        return v.lower()
```

### Serialization Control

```python
class User(ZenithModel, table=True):
    email: str
    password_hash: str = Field(exclude=True)  # Never serialize

    def to_public_dict(self) -> dict:
        """Control what gets exposed."""
        return {
            'id': self.id,
            'email': self.email,
            'created_at': self.created_at.isoformat()
        }
```

### Soft Deletes

```python
class SoftDeleteModel(ZenithModel):
    deleted_at: datetime | None = None

    @classmethod
    def active(cls):
        """Query only non-deleted records."""
        return cls.where(deleted_at=None)

    async def soft_delete(self):
        """Mark as deleted instead of removing."""
        await self.update(deleted_at=datetime.utcnow())

class User(SoftDeleteModel, table=True):
    email: str
    name: str

# Use soft delete pattern
active_users = await User.active().all()
await user.soft_delete()  # Doesn't actually delete
```

## Best Practices

###  DO
- Use ZenithModel for standard web applications
- Leverage built-in methods for common operations
- Add custom validation with Pydantic validators
- Create base models for shared fields
- Use type hints for better IDE support

### ‚ùå DON'T
- Don't put business logic in models
- Don't expose sensitive fields in serialization
- Don't use for complex multi-database transactions
- Don't ignore validation errors
- Don't bypass the ORM for simple queries

## Troubleshooting

### Common Issues

**"No session available"**
- Ensure you're using ZenithModel, not SQLModel
- Check that the Zenith app middleware is configured
- Verify you're in an async request context

**"Relationship not loaded"**
- Use `.includes('relationship')` for eager loading
- Check foreign key definitions
- Ensure related models are imported

**"Validation error on create"**
- Check field constraints match your data
- Verify required fields are provided
- Look for custom validator errors

### Performance Tips

1. **Use select_related for joins**
   ```python
   posts = await Post.includes('author', 'comments').all()
   ```

2. **Paginate large datasets**
   ```python
   users = await User.paginate(page=1, per_page=20)
   ```

3. **Index frequently queried fields**
   ```python
   email: str = Field(unique=True, index=True)
   ```

4. **Use bulk operations**
   ```python
   await User.bulk_create(user_list)
   ```

## Testing Models

```python
import pytest
from zenith.testing import TestClient

@pytest.mark.asyncio
async def test_user_creation():
    async with TestClient(app) as client:
        response = await client.post("/users", json={
            "email": "test@company.com",
            "name": "Test User"
        })

        assert response.status_code == 201
        user = response.json()["user"]
        assert user["email"] == "test@company.com"

@pytest.mark.asyncio
async def test_user_validation():
    with pytest.raises(ValueError, match="Email domain"):
        User(email="test@invalid.com", name="Test")
```

## Migration Guide

### From SQLAlchemy
```python
# Before: SQLAlchemy
session.query(User).filter(User.active == True).limit(10).all()

# After: ZenithModel
await User.where(active=True).limit(10).all()
```

### From Django ORM
```python
# Before: Django
User.objects.filter(active=True).order_by('-created_at')[:10]

# After: ZenithModel
await User.where(active=True).order_by('-created_at').limit(10).all()
```

## Related Topics

- [Services & Business Logic](/zenith/concepts/services/) - Organizing complex operations
- [Authentication](/zenith/concepts/authentication/) - Protecting model operations
- [Testing](/zenith/api/testing/) - Testing database operations
- [Database Migrations](/zenith/concepts/database/) - Schema management

---

*Learn more in the [complete documentation](/zenith/api/application/) or explore [example applications](/zenith/examples/).*