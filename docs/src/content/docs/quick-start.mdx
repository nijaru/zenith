---
title: Quick Start
description: Build your first Zenith API in 5 minutes
---

import { Aside } from '@astrojs/starlight/components';

In this tutorial, you'll build a blog API with Zenith. You'll learn how to:

- Create a Zenith application
- Define data models
- Build API endpoints
- Test your API

<Aside type="tip">
  **Prerequisites**: Python 3.12 or higher. If you don't have it, [download Python here](https://python.org).
</Aside>

## Installation

```bash
pip install zenith-web
```

Or with uv (recommended):

```bash
uv add zenith-web
```

## Create a New Project

Use the Zenith CLI to create a new project with all the essentials:

```bash
zen new blog-api
cd blog-api
```

This creates:
- `app.py` - Main application with sample endpoints
- `.env` - Environment variables with generated secret key
- `requirements.txt` - Dependencies
- `.gitignore` - Git ignore rules
- `README.md` - Quick start guide


## Your First Application

Let's build a complete blog API. This example showcases Zenith's key features: database models, authentication, and API documentation - all with minimal code:

Create a file `app.py`:

```python
"""
Blog API - A complete API with authentication, database, and documentation.
"""

from datetime import datetime
from typing import Optional

from zenith import Zenith
from zenith.db import ZenithModel  # Enhanced SQLModel base class
from sqlmodel import Field

# Chain methods to add features - each returns the app for chaining
app = (Zenith()              # Create base application
       .add_auth()           # Add JWT authentication endpoints (/auth/login, /auth/register)
       .add_admin()          # Add admin dashboard (/admin)
       .add_api("Blog API", "1.0.0"))  # Add OpenAPI docs (/docs, /redoc)

# Database Models
# ZenithModel extends SQLModel with convenience methods like .find(), .create(), .where()
class Post(ZenithModel, table=True):  # table=True creates database table
    """Blog post model - automatically gets CRUD operations."""

    # Optional[int] with primary_key=True means auto-incrementing ID
    id: Optional[int] = Field(primary_key=True)

    # Field constraints are validated at database AND API level
    title: str = Field(max_length=200)          # Max 200 characters
    content: str                                # No length limit
    author: str = Field(max_length=100)         # Max 100 characters

    # Default values for new records
    published: bool = Field(default=False)      # Draft by default
    created_at: datetime = Field(default_factory=datetime.utcnow)  # Auto-timestamp

# API Endpoints
@app.get("/")
async def root():
    """API root - provides discovery information for clients."""
    return {
        "message": "Welcome to Blog API",
        "version": "1.0.0",
        "endpoints": {
            "posts": "/posts",     # Main content endpoints
            "health": "/health",   # Service health check
            "docs": "/docs"        # Interactive API documentation
        }
    }

@app.get("/posts")
async def get_posts(published: bool = True):  # Query param: ?published=false for drafts
    """
    List posts with optional filtering.
    Query parameters are automatically parsed from the URL.
    """
    if published:
        # ZenithModel provides chainable query methods:
        # .where() adds filter, .order_by() sorts, .limit() restricts count
        # The '-' prefix means descending order (newest first)
        posts = await Post.where(published=True).order_by('-created_at').limit(10)
    else:
        # Get all posts, including drafts
        posts = await Post.order_by('-created_at').limit(10)

    return {
        "posts": [post.to_dict() for post in posts],  # .to_dict() converts model to JSON-safe dict
        "count": len(posts)
    }

@app.post("/posts")
async def create_post(post_data: dict):  # Request body automatically parsed from JSON
    """
    Create a new blog post.
    Zenith automatically validates the JSON request body.
    """
    # Post.create() is a ZenithModel convenience method that:
    # 1. Creates the model instance
    # 2. Saves to database
    # 3. Returns the saved instance with generated ID
    post = await Post.create(**post_data)  # ** unpacks dict as keyword arguments

    return {
        "post": post.to_dict(),
        "message": "Post created successfully"
    }

@app.get("/posts/{post_id}")
async def get_post(post_id: int):  # Path param with type validation
    """
    Get a specific post by ID.
    The {post_id} in the path becomes a function parameter.
    """
    # .find_or_404() is a ZenithModel convenience that:
    # - Returns the model if found
    # - Raises HTTP 404 exception if not found
    post = await Post.find_or_404(post_id)
    return {"post": post.to_dict()}

@app.put("/posts/{post_id}")
async def update_post(post_id: int, updates: dict):  # Combines path param + request body
    """Update an existing post - partial updates supported."""
    # First, find the post (404 if not exists)
    post = await Post.find_or_404(post_id)

    # Apply updates - only modify fields present in the request
    for field, value in updates.items():
        # hasattr() checks if the field exists on the model
        # This prevents setting invalid attributes
        if hasattr(post, field):
            setattr(post, field, value)  # Python's way to set object.field = value

    # Save changes to database
    await post.save()

    return {
        "post": post.to_dict(),
        "message": "Post updated successfully"
    }

@app.delete("/posts/{post_id}")
async def delete_post(post_id: int):
    """Delete a post - permanent removal from database."""
    post = await Post.find_or_404(post_id)  # Find or 404
    await post.delete()                      # Remove from database
    return {"message": "Post deleted successfully"}

@app.get("/health")
async def health():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "blog-api"
    }

if __name__ == "__main__":
    app.run()
```

## Run the Server

Start the development server:

```bash
zen dev
```

Or run directly:

```bash
python app.py
```

Your API is now running at http://localhost:8000!

<Aside type="tip">
  The `zen dev` command includes hot reload, so your server will automatically restart when you make changes to your code.
</Aside>

## Interactive API Documentation

Visit these endpoints in your browser or API client:

- **API Root**: http://localhost:8000/
- **API Documentation**: http://localhost:8000/docs
- **Health Check**: http://localhost:8000/health
- **Blog Posts**: http://localhost:8000/posts

## Test Your API

Create a blog post using curl or your API client:

```bash
curl -X POST http://localhost:8000/posts \
  -H "Content-Type: application/json" \
  -d '{
    "title": "My First Post",
    "content": "This is my first blog post using Zenith!",
    "author": "Developer",
    "published": true
  }'
```

Get all posts:

```bash
curl http://localhost:8000/posts
```

## Key Features

### Database Models

```python
from zenith.db import ZenithModel

class User(ZenithModel, table=True):
    id: int | None = Field(primary_key=True)
    name: str
    email: str

# Intuitive operations
users = await User.all()
user = await User.find(1)
user = await User.create(name="Alice", email="alice@example.com")
active_users = await User.where(active=True).limit(10)
```

### Dependency Injection

```python
from zenith.core import DB, Auth, Inject

@app.get("/users")
async def get_users(
    db=DB,                         # Database session shortcut
    user=Auth,                     # Current authenticated user
    users: UserService = Inject()  # Service injection
):
    # Clean, readable code with modern shortcuts
    pass
```

### Built-in Features

- **Hot reload** - Automatic restart on code changes
- **API documentation** - Interactive docs at `/docs` and `/redoc`
- **Health checks** - Monitoring endpoints at `/health`
- **Authentication** - JWT auth with `app.add_auth()`
- **Admin panel** - Dashboard with `app.add_admin()`
- **Middleware** - Security, CORS, compression included

## Next Steps

### Add Authentication (Built-in!)

```python
# Authentication is already enabled with app.add_auth()!
# Just use the Auth dependency:

from zenith.core import Auth

@app.get("/protected")
async def protected_route(user=Auth):
    return {"user_id": user.id}

# Login endpoint automatically available at /auth/login
```

### Add Server-Sent Events

```python
from zenith.web.sse import create_sse_response
import asyncio

@app.get("/events")
async def stream_events():
    """Real-time event streaming."""
    async def events():
        for i in range(100):
            yield {
                "type": "count",
                "data": {"value": i}
            }
            await asyncio.sleep(1)

    return create_sse_response(events())
```

### Add File Uploads

```python
from zenith.web import File
from starlette.responses import JSONResponse

@app.post("/upload")
async def upload_file(file: File):
    """Handle file uploads with built-in validation."""
    contents = await file.read()
    return JSONResponse({
        "filename": file.filename,
        "size": len(contents)
    })
```

### Organize with Services

```python
from zenith.core import Inject

class PostService:
    """Business logic for posts."""

    async def create_post(self, data: dict) -> Post:
        # Validation, business rules, etc.
        return await Post.create(**data)

# Use in routes
@app.post("/posts")
async def create_post(
    data: dict,
    posts: PostService = Inject()
):
    post = await posts.create_post(data)
    return {"post": post.to_dict()}
```

## Key Features

### Current Python

- **Python 3.12+** with latest features
- **Type hints** throughout for better IDE support
- **Async/await** for high performance
- **Pydantic v2** for validation and serialization

### Developer Experience

- **Minimal setup code** - Focus on business logic
- **Good tooling** - CLI, hot reload, debugging
- **Clear patterns** - Consistent code organization
- **Great defaults** - Secure and performant out of the box

### Production Ready

- **Security** - CSRF, rate limiting, secure headers
- **Performance** - Optimized middleware stack
- **Monitoring** - Health checks, metrics, logging
- **Scalability** - Async throughout, connection pooling

## Advanced Features

### WebSockets

```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Echo: {data}")
```

### Background Tasks

```python
from zenith.background import BackgroundTasks

@app.post("/send-email")
async def send_email(email: str, background: BackgroundTasks):
    background.add_task(send_email_async, email)
    return {"status": "queued"}
```

### Rate Limiting

```python
@app.get("/api/data")
@rate_limit("10/minute")
async def get_data():
    return {"data": "rate limited"}

## Next Steps

- [Routing](./concepts/routing) - Path parameters, query strings, request bodies
- [Models](./concepts/models) - Database models and queries
- [Authentication](./concepts/authentication) - Securing your API
- [Testing](./api/testing) - Writing tests for your API
- [Deployment](./guides/deployment) - Deploy to production

---

*Learn more in the [complete documentation](/zenith/concepts/routing/) or explore [example applications](/zenith/examples/).*