---
title: Quick Start
description: Build your first Zenith API in 5 minutes
---

import { Aside } from '@astrojs/starlight/components';

In this tutorial, you'll build a blog API with Zenith. You'll learn how to:

- Create a Zenith application
- Define data models
- Build API endpoints
- Test your API

<Aside type="tip">
  **Prerequisites**: Python 3.12 or higher. If you don't have it, [download Python here](https://python.org).
</Aside>

## Installation

```bash
pip install zenith-web
```

Or with uv (recommended):

```bash
uv add zenith-web
```

## Create a New Project

Use the Zenith CLI to create a new project with all the essentials:

```bash
zen new blog-api
cd blog-api
```

This creates:
- `app.py` - Main application with sample endpoints
- `.env` - Environment variables with generated secret key
- `requirements.txt` - Dependencies
- `.gitignore` - Git ignore rules
- `README.md` - Quick start guide


## Your First Application

Create a file `app.py` with a blog API:

```python
"""
Blog API - Zenith application demonstrating modern patterns.
"""

from datetime import datetime
from typing import Optional

from zenith import Zenith
from zenith.db import ZenithModel
from sqlmodel import Field

# Create Zenith application with built-in features
app = (Zenith()
       .add_auth()
       .add_admin()
       .add_api("Blog API", "1.0.0"))

#  SQLModel with better defaults
class Post(ZenithModel, table=True):
    """Blog post model with Zenith enhancements."""

    id: Optional[int] = Field(primary_key=True)
    title: str = Field(max_length=200)
    content: str
    author: str = Field(max_length=100)
    published: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)

# API Endpoints
@app.get("/")
async def root():
    """API root with information."""
    return {
        "message": "Welcome to Blog API",
        "version": "1.0.0",
        "endpoints": {
            "posts": "/posts",
            "health": "/health",
            "docs": "/docs"
        }
    }

@app.get("/posts")
async def get_posts(published: bool = True):
    """Get blog posts with filtering."""
    if published:
        posts = await Post.where(published=True).order_by('-created_at').limit(10)
    else:
        posts = await Post.order_by('-created_at').limit(10)

    return {
        "posts": [post.to_dict() for post in posts],
        "count": len(posts)
    }

@app.post("/posts")
async def create_post(post_data: dict):
    """Create a new blog post."""
    post = await Post.create(**post_data)

    return {
        "post": post.to_dict(),
        "message": "Post created successfully"
    }

@app.get("/posts/{post_id}")
async def get_post(post_id: int):
    """Get a specific post by ID."""
    post = await Post.find_or_404(post_id)
    return {"post": post.to_dict()}

@app.put("/posts/{post_id}")
async def update_post(post_id: int, updates: dict):
    """Update an existing post."""
    post = await Post.find_or_404(post_id)

    # Update fields
    for field, value in updates.items():
        if hasattr(post, field):
            setattr(post, field, value)

    await post.save()

    return {
        "post": post.to_dict(),
        "message": "Post updated successfully"
    }

@app.delete("/posts/{post_id}")
async def delete_post(post_id: int):
    """Delete a post."""
    post = await Post.find_or_404(post_id)
    await post.delete()
    return {"message": "Post deleted successfully"}

@app.get("/health")
async def health():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "blog-api"
    }

if __name__ == "__main__":
    app.run()
```

## Run the Server

Start the development server:

```bash
zen dev
```

Or run directly:

```bash
python app.py
```

Your API is now running at http://localhost:8000!

<Aside type="tip">
  The `zen dev` command includes hot reload, so your server will automatically restart when you make changes to your code.
</Aside>

## Interactive API Documentation

Visit these endpoints in your browser or API client:

- **API Root**: http://localhost:8000/
- **API Documentation**: http://localhost:8000/docs
- **Health Check**: http://localhost:8000/health
- **Blog Posts**: http://localhost:8000/posts

## Test Your API

Create a blog post using curl or your API client:

```bash
curl -X POST http://localhost:8000/posts \
  -H "Content-Type: application/json" \
  -d '{
    "title": "My First Post",
    "content": "This is my first blog post using Zenith!",
    "author": "Developer",
    "published": true
  }'
```

Get all posts:

```bash
curl http://localhost:8000/posts
```

## Key Features

### Database Models

```python
from zenith.db import ZenithModel

class User(ZenithModel, table=True):
    id: int | None = Field(primary_key=True)
    name: str
    email: str

# Intuitive operations
users = await User.all()
user = await User.find(1)
user = await User.create(name="Alice", email="alice@example.com")
active_users = await User.where(active=True).limit(10)
```

### Dependency Injection

```python
from zenith.core import DB, Auth, Inject

@app.get("/users")
async def get_users(
    db=DB,                         # Database session shortcut
    user=Auth,                     # Current authenticated user
    users: UserService = Inject()  # Service injection
):
    # Clean, readable code with modern shortcuts
    pass
```

### Built-in Features

- **Hot reload** - Automatic restart on code changes
- **API documentation** - Interactive docs at `/docs` and `/redoc`
- **Health checks** - Monitoring endpoints at `/health`
- **Authentication** - JWT auth with `app.add_auth()`
- **Admin panel** - Dashboard with `app.add_admin()`
- **Middleware** - Security, CORS, compression included

## Next Steps

### Add Authentication (Built-in!)

```python
# Authentication is already enabled with app.add_auth()!
# Just use the Auth dependency:

from zenith.core import Auth

@app.get("/protected")
async def protected_route(user=Auth):
    return {"user_id": user.id}

# Login endpoint automatically available at /auth/login
```

### Add Server-Sent Events

```python
from zenith.web.sse import create_sse_response
import asyncio

@app.get("/events")
async def stream_events():
    """Real-time event streaming."""
    async def events():
        for i in range(100):
            yield {
                "type": "count",
                "data": {"value": i}
            }
            await asyncio.sleep(1)

    return create_sse_response(events())
```

### Add File Uploads

```python
from zenith.web import File
from starlette.responses import JSONResponse

@app.post("/upload")
async def upload_file(file: File):
    """Handle file uploads with built-in validation."""
    contents = await file.read()
    return JSONResponse({
        "filename": file.filename,
        "size": len(contents)
    })
```

### Organize with Services

```python
from zenith.core import Inject

class PostService:
    """Business logic for posts."""

    async def create_post(self, data: dict) -> Post:
        # Validation, business rules, etc.
        return await Post.create(**data)

# Use in routes
@app.post("/posts")
async def create_post(
    data: dict,
    posts: PostService = Inject()
):
    post = await posts.create_post(data)
    return {"post": post.to_dict()}
```

## Key Features

### Current Python

- **Python 3.12+** with latest features
- **Type hints** throughout for better IDE support
- **Async/await** for high performance
- **Pydantic v2** for validation and serialization

### Developer Experience

- **Minimal setup code** - Focus on business logic
- **Good tooling** - CLI, hot reload, debugging
- **Clear patterns** - Consistent code organization
- **Great defaults** - Secure and performant out of the box

### Production Ready

- **Security** - CSRF, rate limiting, secure headers
- **Performance** - Optimized middleware stack
- **Monitoring** - Health checks, metrics, logging
- **Scalability** - Async throughout, connection pooling

## Advanced Features

### WebSockets

```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Echo: {data}")
```

### Background Tasks

```python
from zenith.background import BackgroundTasks

@app.post("/send-email")
async def send_email(email: str, background: BackgroundTasks):
    background.add_task(send_email_async, email)
    return {"status": "queued"}
```

### Rate Limiting

```python
@app.get("/api/data")
@rate_limit("10/minute")
async def get_data():
    return {"data": "rate limited"}

## Next Steps

- [Routing](./concepts/routing) - Path parameters, query strings, request bodies
- [Models](./concepts/models) - Database models and queries
- [Authentication](./concepts/authentication) - Securing your API
- [Testing](./api/testing) - Writing tests for your API
- [Deployment](./guides/deployment) - Deploy to production

---

*Learn more in the [complete documentation](/zenith/concepts/routing/) or explore [example applications](/zenith/examples/).*