---
title: Quick Start
description: Build your first Zenith API in 5 minutes
---

import { Aside } from '@astrojs/starlight/components';

In this tutorial, you'll build a complete blog API with Zenith in just 5 minutes. You'll see how Zenith eliminates the complexity of traditional Python web development.

**What you'll learn:**
- How Zenith replaces hundreds of lines of boilerplate with simple commands
- Why ZenithModel makes database operations intuitive
- How one-liner features add authentication, admin panels, and docs
- The dramatic difference between traditional vs modern Python web development

<Aside type="tip">
  **Prerequisites**: Python 3.12 or higher. If you don't have it, [download Python here](https://python.org).
</Aside>

## Installation

```bash
pip install zenith-web
```

Or with uv (recommended):

```bash
uv add zenith-web
```

## Create a New Project

Use the Zenith CLI to create a new project with all the essentials:

```bash
zen new blog-api
cd blog-api
```

This creates:
- `app.py` - Main application with sample endpoints
- `.env` - Environment variables with generated secret key
- `requirements.txt` - Dependencies
- `.gitignore` - Git ignore rules
- `README.md` - Quick start guide


## Your First Application

### Building a Blog API: Traditional Approach
```python
# Modern Python with SQLModel (combining Pydantic + SQLAlchemy)
from typing import Optional, List
from sqlmodel import Field, Session, SQLModel, create_engine, select
from datetime import datetime
from contextlib import asynccontextmanager
import os

# Database configuration
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./blog.db")
engine = create_engine(DATABASE_URL)

# Model definition using SQLModel (Pydantic + SQLAlchemy)
class PostBase(SQLModel):
    title: str = Field(index=True)
    content: str
    published: bool = Field(default=False)

class Post(PostBase, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)

class PostCreate(PostBase):
    pass

class PostRead(PostBase):
    id: int
    created_at: datetime

# Application setup with lifespan
@asynccontextmanager
async def lifespan(app):
    # Create tables on startup
    SQLModel.metadata.create_all(engine)
    yield

# Application initialization (framework-specific)
app = create_application(
    title="Blog API",
    version="1.0.0",
    lifespan=lifespan
)

# Session dependency
def get_session():
    with Session(engine) as session:
        yield session

# CRUD endpoints
@app.post("/posts/", response_model=PostRead)
def create_post(post: PostCreate, session: Session):  # Session injection pattern
    db_post = Post.model_validate(post)
    session.add(db_post)
    session.commit()
    session.refresh(db_post)
    return db_post

@app.get("/posts/", response_model=List[PostRead])
def list_posts(
    published: Optional[bool] = None,
    skip: int = 0,
    limit: int = 10,
    session: Session  # Framework handles injection
):
    statement = select(Post)
    if published is not None:
        statement = statement.where(Post.published == published)
    statement = statement.offset(skip).limit(limit)
    posts = session.exec(statement).all()
    return posts

# Still missing:
# - Authentication (JWT setup, login endpoints, user management)
# - Admin interface (doesn't exist without third-party packages)
# - Advanced query methods (complex filtering, sorting)
# - Background tasks
# - WebSocket support
# - Production middleware (CORS, security headers, rate limiting)
```

### Building the Same API with Zenith
```python
# Zenith - Enhanced developer experience
from zenith import Zenith
from zenith.db import ZenithModel
from sqlmodel import Field
from datetime import datetime
from typing import Optional

# Application setup with automatic configuration
app = Zenith()  # Auto-configures database, middleware, error handling

# Optional: Add additional features with one-liners
app.add_auth()              # JWT authentication with login endpoint
app.add_admin("/admin")     # Admin dashboard for monitoring
app.add_api("Blog API", "1.0.0")  # Enhanced API documentation

# Model with ActiveRecord-style methods
class Post(ZenithModel, table=True):
    """Blog post model with built-in query methods."""
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(index=True)
    content: str
    published: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)

# CRUD endpoints with automatic session management
@app.post("/posts")
async def create_post(title: str, content: str, published: bool = False):
    """Create a new blog post.

    ZenithModel provides:
    - Automatic session management (no Depends needed)
    - Built-in validation
    - Transaction handling
    """
    post = await Post.create(
        title=title,
        content=content,
        published=published
    )
    return {"post": post.to_dict()}

@app.get("/posts")
async def list_posts(
    published: Optional[bool] = None,
    skip: int = 0,
    limit: int = 10
):
    """List blog posts with filtering.

    ZenithModel provides chainable query methods similar to Rails ActiveRecord.
    """
    query = Post.query()  # Start query builder

    if published is not None:
        query = query.where(published=published)

    posts = await query.order_by('-created_at').offset(skip).limit(limit).all()

    return {
        "posts": [p.to_dict() for p in posts],
        "total": await query.count(),
        "skip": skip,
        "limit": limit
    }

@app.get("/posts/{post_id}")
async def get_post(post_id: int):
    """Get a single post by ID.

    find_or_404() automatically raises HTTPException if not found.
    """
    post = await Post.find_or_404(post_id)
    return {"post": post.to_dict()}

# That's it! You now have:
# Complete CRUD API
# Authentication (/auth/login)
# Admin dashboard (/admin)
# Interactive docs (/docs)
# Type safety throughout
# Automatic session management
# Security middleware
```

**Comparison:**

| Feature | Traditional Approach | Zenith |
|---------|---------------------|--------|
| **Lines of Code** | ~80-100 (basic CRUD only) | ~40-50 (with more features) |
| **Database Sessions** | Manual `Depends(get_session)` | Automatic per-request |
| **Query Methods** | SQLAlchemy syntax | Rails-like chainable |
| **404 Handling** | Manual check and raise | `find_or_404()` method |
| **Serialization** | Pydantic models | Built-in `to_dict()` |
| **Authentication** | Build yourself (~150 lines) | `app.add_auth()` |
| **Admin Interface** | Third-party or none | `app.add_admin()` |
| **Setup Time** | 30-60 minutes | 5-10 minutes |

**What Zenith Provides:**
- Cleaner, more intuitive API (subjective but important for DX)
- Automatic session management reduces boilerplate
- Rails-like query methods familiar to many developers
- Optional batteries-included features (auth, admin)
- Faster initial development, especially for prototypes
- Convention over configuration philosophy

**Trade-offs to Consider:**
- Traditional frameworks may have larger ecosystems
- Raw SQLAlchemy offers more flexibility for complex queries
- Zenith's conventions may not fit all use cases
- Learning curve if unfamiliar with Rails-like patterns

Create a file `app.py`:

```python
"""
Blog API - A complete API with authentication, database, and documentation.
"""

from datetime import datetime
from typing import Optional

from zenith import Zenith
from zenith.db import ZenithModel  # Enhanced SQLModel base class
from sqlmodel import Field

# Chain methods to add features - each returns the app for chaining
app = (Zenith()              # Create base application
       .add_auth()           # Add JWT authentication endpoints (/auth/login, /auth/register)
       .add_admin()          # Add admin dashboard (/admin)
       .add_api("Blog API", "1.0.0"))  # Add OpenAPI docs (/docs, /redoc)

# Database Models
# ZenithModel extends SQLModel with convenience methods like .find(), .create(), .where()
class Post(ZenithModel, table=True):  # table=True creates database table
    """Blog post model - automatically gets CRUD operations."""

    # Optional[int] with primary_key=True means auto-incrementing ID
    id: Optional[int] = Field(primary_key=True)

    # Field constraints are validated at database AND API level
    title: str = Field(max_length=200)          # Max 200 characters
    content: str                                # No length limit
    author: str = Field(max_length=100)         # Max 100 characters

    # Default values for new records
    published: bool = Field(default=False)      # Draft by default
    created_at: datetime = Field(default_factory=datetime.utcnow)  # Auto-timestamp

# API Endpoints
@app.get("/")
async def root():
    """API root - provides discovery information for clients."""
    return {
        "message": "Welcome to Blog API",
        "version": "1.0.0",
        "endpoints": {
            "posts": "/posts",     # Main content endpoints
            "health": "/health",   # Service health check
            "docs": "/docs"        # Interactive API documentation
        }
    }

@app.get("/posts")
async def get_posts(published: bool = True):  # Query param: ?published=false for drafts
    """
    List posts with optional filtering.
    Query parameters are automatically parsed from the URL.
    """
    if published:
        # ZenithModel provides chainable query methods:
        # .where() adds filter, .order_by() sorts, .limit() restricts count
        # The '-' prefix means descending order (newest first)
        posts = await Post.where(published=True).order_by('-created_at').limit(10)
    else:
        # Get all posts, including drafts
        posts = await Post.order_by('-created_at').limit(10)

    return {
        "posts": [post.to_dict() for post in posts],  # .to_dict() converts model to JSON-safe dict
        "count": len(posts)
    }

@app.post("/posts")
async def create_post(post_data: dict):  # Request body automatically parsed from JSON
    """
    Create a new blog post.
    Zenith automatically validates the JSON request body.
    """
    # Post.create() is a ZenithModel convenience method that:
    # 1. Creates the model instance
    # 2. Saves to database
    # 3. Returns the saved instance with generated ID
    post = await Post.create(**post_data)  # ** unpacks dict as keyword arguments

    return {
        "post": post.to_dict(),
        "message": "Post created successfully"
    }

@app.get("/posts/{post_id}")
async def get_post(post_id: int):  # Path param with type validation
    """
    Get a specific post by ID.
    The {post_id} in the path becomes a function parameter.
    """
    # .find_or_404() is a ZenithModel convenience that:
    # - Returns the model if found
    # - Raises HTTP 404 exception if not found
    post = await Post.find_or_404(post_id)
    return {"post": post.to_dict()}

@app.put("/posts/{post_id}")
async def update_post(post_id: int, updates: dict):  # Combines path param + request body
    """Update an existing post - partial updates supported."""
    # First, find the post (404 if not exists)
    post = await Post.find_or_404(post_id)

    # Apply updates - only modify fields present in the request
    for field, value in updates.items():
        # hasattr() checks if the field exists on the model
        # This prevents setting invalid attributes
        if hasattr(post, field):
            setattr(post, field, value)  # Python's way to set object.field = value

    # Save changes to database
    await post.save()

    return {
        "post": post.to_dict(),
        "message": "Post updated successfully"
    }

@app.delete("/posts/{post_id}")
async def delete_post(post_id: int):
    """Delete a post - permanent removal from database."""
    post = await Post.find_or_404(post_id)  # Find or 404
    await post.delete()                      # Remove from database
    return {"message": "Post deleted successfully"}

@app.get("/health")
async def health():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "blog-api"
    }

if __name__ == "__main__":
    app.run()
```

## Run the Server

Start the development server:

```bash
zen dev
```

Or run directly:

```bash
python app.py
```

Your API is now running at http://localhost:8000!

<Aside type="tip">
  The `zen dev` command includes hot reload, so your server will automatically restart when you make changes to your code.
</Aside>

## Interactive API Documentation

Visit these endpoints in your browser or API client:

- **API Root**: http://localhost:8000/
- **API Documentation**: http://localhost:8000/docs
- **Health Check**: http://localhost:8000/health
- **Blog Posts**: http://localhost:8000/posts

## Test Your API

Create a blog post using curl or your API client:

```bash
curl -X POST http://localhost:8000/posts \
  -H "Content-Type: application/json" \
  -d '{
    "title": "My First Post",
    "content": "This is my first blog post using Zenith!",
    "author": "Developer",
    "published": true
  }'
```

Get all posts:

```bash
curl http://localhost:8000/posts
```

## Key Features

### Database Models

```python
from zenith.db import ZenithModel

class User(ZenithModel, table=True):
    id: int | None = Field(primary_key=True)
    name: str
    email: str

# Intuitive operations
users = await User.all()
user = await User.find(1)
user = await User.create(name="Alice", email="alice@example.com")
active_users = await User.where(active=True).limit(10)
```

### Dependency Injection

```python
from zenith.core import DB, Auth, Inject

@app.get("/users")
async def get_users(
    db=DB,                         # Database session shortcut
    user=Auth,                     # Current authenticated user
    users: UserService = Inject()  # Service injection
):
    # Clean, readable code with modern shortcuts
    pass
```

### Built-in Features

- **Hot reload** - Automatic restart on code changes
- **API documentation** - Interactive docs at `/docs` and `/redoc`
- **Health checks** - Monitoring endpoints at `/health`
- **Authentication** - JWT auth with `app.add_auth()`
- **Admin panel** - Dashboard with `app.add_admin()`
- **Middleware** - Security, CORS, compression included

## Next Steps

### Add Authentication (Built-in!)

```python
# Authentication is already enabled with app.add_auth()!
# Just use the Auth dependency:

from zenith.core import Auth

@app.get("/protected")
async def protected_route(user=Auth):
    return {"user_id": user.id}

# Login endpoint automatically available at /auth/login
```

### Add Server-Sent Events

```python
from zenith.web.sse import create_sse_response
import asyncio

@app.get("/events")
async def stream_events():
    """Real-time event streaming."""
    async def events():
        for i in range(100):
            yield {
                "type": "count",
                "data": {"value": i}
            }
            await asyncio.sleep(1)

    return create_sse_response(events())
```

### Add File Uploads

```python
from zenith.web import File
from starlette.responses import JSONResponse

@app.post("/upload")
async def upload_file(file: File):
    """Handle file uploads with built-in validation."""
    contents = await file.read()
    return JSONResponse({
        "filename": file.filename,
        "size": len(contents)
    })
```

### Organize with Services

```python
from zenith.core import Inject

class PostService:
    """Business logic for posts."""

    async def create_post(self, data: dict) -> Post:
        # Validation, business rules, etc.
        return await Post.create(**data)

# Use in routes
@app.post("/posts")
async def create_post(
    data: dict,
    posts: PostService = Inject()
):
    post = await posts.create_post(data)
    return {"post": post.to_dict()}
```

## Key Features

### Current Python

- **Python 3.12+** with latest features
- **Type hints** throughout for better IDE support
- **Async/await** for high performance
- **Pydantic v2** for validation and serialization

### Developer Experience

- **Minimal setup code** - Focus on business logic
- **Good tooling** - CLI, hot reload, debugging
- **Clear patterns** - Consistent code organization
- **Great defaults** - Secure and performant out of the box

### Production Ready

- **Security** - CSRF, rate limiting, secure headers
- **Performance** - Optimized middleware stack
- **Monitoring** - Health checks, metrics, logging
- **Scalability** - Async throughout, connection pooling

## Advanced Features

### WebSockets

```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Echo: {data}")
```

### Background Tasks

```python
from zenith.background import BackgroundTasks

@app.post("/send-email")
async def send_email(email: str, background: BackgroundTasks):
    background.add_task(send_email_async, email)
    return {"status": "queued"}
```

### Rate Limiting

```python
@app.get("/api/data")
@rate_limit("10/minute")
async def get_data():
    return {"data": "rate limited"}

## Next Steps

- [Routing](./concepts/routing) - Path parameters, query strings, request bodies
- [Models](./concepts/models) - Database models and queries
- [Authentication](./concepts/authentication) - Securing your API
- [Testing](./api/testing) - Writing tests for your API
- [Deployment](./guides/deployment) - Deploy to production

---

*Learn more in the [complete documentation](/zenith/concepts/routing/) or explore [example applications](/zenith/examples/).*